   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB13:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:stk500boot.c  **** License:   GNU General Public License
   8:stk500boot.c  **** 
   9:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:stk500boot.c  **** Date:      17 October 2007
  11:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:stk500boot.c  **** Compiler:  WINAVR20060421
  13:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  14:stk500boot.c  **** 
  15:stk500boot.c  **** DESCRIPTION:
  16:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  17:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  18:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  19:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  20:stk500boot.c  ****     "reset" vector in Application area.
  21:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  22:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  23:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  24:stk500boot.c  **** 
  25:stk500boot.c  **** USAGE:
  26:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  27:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  28:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  29:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  30:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  31:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  32:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  33:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  34:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  35:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  36:stk500boot.c  ****     - AVRISP will detect the bootloader
  37:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  38:stk500boot.c  **** 
  39:stk500boot.c  **** Note:
  40:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  41:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  42:stk500boot.c  ****     Flash is always erased before programming.
  43:stk500boot.c  **** 
  44:stk500boot.c  **** 	AVRdude:
  45:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  46:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  47:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  48:stk500boot.c  **** 
  49:stk500boot.c  **** NOTES:
  50:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  51:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  52:stk500boot.c  **** 
  53:stk500boot.c  **** LICENSE:
  54:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  55:stk500boot.c  **** 
  56:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  57:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  58:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  59:stk500boot.c  ****     any later version.
  60:stk500boot.c  **** 
  61:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  62:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  63:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  64:stk500boot.c  ****     GNU General Public License for more details.
  65:stk500boot.c  **** 
  66:stk500boot.c  **** *****************************************************************************/
  67:stk500boot.c  **** 
  68:stk500boot.c  **** //************************************************************************
  69:stk500boot.c  **** //*	Edit History
  70:stk500boot.c  **** //************************************************************************
  71:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  74:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  76:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  78:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  79:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  80:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  81:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  82:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  83:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  84:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  86:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  89:stk500boot.c  **** //************************************************************************
  90:stk500boot.c  **** 
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** #include	<inttypes.h>
 104:stk500boot.c  **** #include	<avr/io.h>
 105:stk500boot.c  **** #include	<avr/interrupt.h>
 106:stk500boot.c  **** #include	<avr/boot.h>
 107:stk500boot.c  **** #include	<avr/pgmspace.h>
 108:stk500boot.c  **** #include	<util/delay.h>
 109:stk500boot.c  **** #include	<avr/eeprom.h>
 110:stk500boot.c  **** #include	<avr/common.h>
 111:stk500boot.c  **** #include	<stdlib.h>
 112:stk500boot.c  **** #include	"command.h"
 113:stk500boot.c  **** 
 114:stk500boot.c  **** 
 115:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 116:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 117:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 118:stk500boot.c  **** 	#define		ENABLE_MONITOR
 119:stk500boot.c  **** 	static void	RunMonitor(void);
 120:stk500boot.c  **** #endif
 121:stk500boot.c  **** 
 122:stk500boot.c  **** #ifndef EEWE
 123:stk500boot.c  **** 	#define EEWE    1
 124:stk500boot.c  **** #endif
 125:stk500boot.c  **** #ifndef EEMWE
 126:stk500boot.c  **** 	#define EEMWE   2
 127:stk500boot.c  **** #endif
 128:stk500boot.c  **** 
 129:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 130:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 131:stk500boot.c  **** 
 132:stk500boot.c  **** 
 133:stk500boot.c  **** /*
 134:stk500boot.c  ****  * Uncomment the following lines to save code space
 135:stk500boot.c  ****  */
 136:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 137:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 138:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 139:stk500boot.c  **** //
 140:stk500boot.c  **** 
 141:stk500boot.c  **** 
 142:stk500boot.c  **** 
 143:stk500boot.c  **** //************************************************************************
 144:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 145:stk500boot.c  **** //*	indicates that bootloader is active
 146:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 147:stk500boot.c  **** //************************************************************************
 148:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 149:stk500boot.c  **** 
 150:stk500boot.c  **** #ifdef _MEGA_BOARD_
 151:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 152:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 153:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 154:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 155:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 156:stk500boot.c  **** 	//*	onbarod led is PORTE4
 157:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 158:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 159:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 160:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 161:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 162:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 163:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 164:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 165:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 166:stk500boot.c  **** #elif defined( _PENGUINO_ )
 167:stk500boot.c  **** 	//*	this is for the Penguino
 168:stk500boot.c  **** 	//*	onbarod led is PORTE4
 169:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 170:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 171:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 172:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 173:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 174:stk500boot.c  **** 	//*	onbarod led is PORTE4
 175:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 176:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 177:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 178:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 179:stk500boot.c  **** 	//*	onbarod led is PORTA7
 180:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 181:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 182:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 183:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 184:stk500boot.c  **** 
 185:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 186:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 187:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 188:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 189:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 190:stk500boot.c  **** 
 191:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 192:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 193:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 194:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 195:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 196:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 197:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 198:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 199:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 200:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 201:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 202:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 203:stk500boot.c  **** #elif defined( _AVRLIP_ )
 204:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 205:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 206:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 207:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 208:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 209:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 210:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 211:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 212:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 213:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 214:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 215:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 216:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 217:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 218:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 219:stk500boot.c  **** #else
 220:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 221:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 222:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 223:stk500boot.c  **** #endif
 224:stk500boot.c  **** 
 225:stk500boot.c  **** 
 226:stk500boot.c  **** 
 227:stk500boot.c  **** /*
 228:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 229:stk500boot.c  ****  */
 230:stk500boot.c  **** #ifndef F_CPU
 231:stk500boot.c  **** 	#define F_CPU 16000000UL
 232:stk500boot.c  **** #endif
 233:stk500boot.c  **** 
 234:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 235:stk500boot.c  **** /*
 236:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 237:stk500boot.c  ****  */
 238:stk500boot.c  **** 
 239:stk500boot.c  **** #ifndef BAUDRATE
 240:stk500boot.c  **** 	#define BAUDRATE 115200
 241:stk500boot.c  **** #endif
 242:stk500boot.c  **** 
 243:stk500boot.c  **** /*
 244:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 245:stk500boot.c  ****  */
 246:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 247:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 248:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 249:stk500boot.c  **** 	#else
 250:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 251:stk500boot.c  **** 	#endif
 252:stk500boot.c  **** #endif
 253:stk500boot.c  **** 
 254:stk500boot.c  **** /*
 255:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 256:stk500boot.c  ****  */
 257:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 258:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 259:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 260:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 261:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 262:stk500boot.c  **** 
 263:stk500boot.c  **** /*
 264:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 265:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 266:stk500boot.c  ****  */
 267:stk500boot.c  **** //#define BOOTSIZE 1024
 268:stk500boot.c  **** #if FLASHEND > 0x0F000
 269:stk500boot.c  **** 	#define BOOTSIZE 8192
 270:stk500boot.c  **** #else
 271:stk500boot.c  **** 	#define BOOTSIZE 2048
 272:stk500boot.c  **** #endif
 273:stk500boot.c  **** 
 274:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 275:stk500boot.c  **** 
 276:stk500boot.c  **** /*
 277:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 278:stk500boot.c  ****  */
 279:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 280:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 281:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 282:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 283:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 284:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 285:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 286:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 287:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 288:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 289:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 290:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 291:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 292:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 293:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 294:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 295:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 296:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 297:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 298:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 299:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 300:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 301:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 302:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 303:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 304:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 305:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 306:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 307:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 308:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 309:stk500boot.c  **** #else
 310:stk500boot.c  **** 	#error "no signature definition for MCU available"
 311:stk500boot.c  **** #endif
 312:stk500boot.c  **** 
 313:stk500boot.c  **** 
 314:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 315:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 316:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 317:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 318:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 319:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 320:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 321:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 322:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 323:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 324:stk500boot.c  **** 
 325:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 326:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 327:stk500boot.c  **** 	/* ATMega8 with one USART */
 328:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 329:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 330:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 331:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 332:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 333:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 334:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 335:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 336:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 337:stk500boot.c  **** 
 338:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 339:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 340:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 341:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 342:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 343:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 344:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 345:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 346:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 347:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 348:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 349:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 350:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 351:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 352:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 353:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 354:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 355:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 356:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 357:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 358:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 359:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 360:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 361:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 362:stk500boot.c  **** 	//* catch all
 363:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 364:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 365:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 366:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 367:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 368:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 369:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 370:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 371:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 372:stk500boot.c  **** #else
 373:stk500boot.c  **** 	#error "no UART definition for MCU available"
 374:stk500boot.c  **** #endif
 375:stk500boot.c  **** 
 376:stk500boot.c  **** 
 377:stk500boot.c  **** 
 378:stk500boot.c  **** /*
 379:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 380:stk500boot.c  ****  */
 381:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 382:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 383:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 384:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 385:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 386:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 387:stk500boot.c  **** #else
 388:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 389:stk500boot.c  **** #endif
 390:stk500boot.c  **** 
 391:stk500boot.c  **** 
 392:stk500boot.c  **** /*
 393:stk500boot.c  ****  * States used in the receive state machine
 394:stk500boot.c  ****  */
 395:stk500boot.c  **** #define	ST_START		0
 396:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 397:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 398:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 399:stk500boot.c  **** #define ST_GET_TOKEN	4
 400:stk500boot.c  **** #define ST_GET_DATA		5
 401:stk500boot.c  **** #define	ST_GET_CHECK	6
 402:stk500boot.c  **** #define	ST_PROCESS		7
 403:stk500boot.c  **** 
 404:stk500boot.c  **** /*
 405:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 406:stk500boot.c  ****  */
 407:stk500boot.c  **** #if defined(RAMPZ)
 408:stk500boot.c  **** 	typedef uint32_t address_t;
 409:stk500boot.c  **** #else
 410:stk500boot.c  **** 	typedef uint16_t address_t;
 411:stk500boot.c  **** #endif
 412:stk500boot.c  **** 
 413:stk500boot.c  **** /*
 414:stk500boot.c  ****  * function prototypes
 415:stk500boot.c  ****  */
 416:stk500boot.c  **** static void sendchar(char c);
 417:stk500boot.c  **** static unsigned char recchar(void);
 418:stk500boot.c  **** 
 419:stk500boot.c  **** /*
 420:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 421:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 422:stk500boot.c  ****  */
 423:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 424:stk500boot.c  **** #include <avr/sfr_defs.h>
 425:stk500boot.c  **** 
 426:stk500boot.c  **** //#define	SPH_REG	0x3E
 427:stk500boot.c  **** //#define	SPL_REG	0x3D
 428:stk500boot.c  **** 
 429:stk500boot.c  **** //*****************************************************************************
 430:stk500boot.c  **** void __jumpMain(void)
 431:stk500boot.c  **** {
 432:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 433:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 434:stk500boot.c  **** 
 435:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 436:stk500boot.c  **** 
 437:stk500boot.c  **** //*	set stack pointer to top of RAM
 438:stk500boot.c  **** 
 439:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 440:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 441:stk500boot.c  **** 
 442:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 443:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 444:stk500boot.c  **** 
 445:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 446:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 447:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 448:stk500boot.c  **** }
 449:stk500boot.c  **** 
 450:stk500boot.c  **** 
 451:stk500boot.c  **** //*****************************************************************************
 452:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 453:stk500boot.c  **** {
 454:stk500boot.c  **** 	unsigned int i;
 455:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 456:stk500boot.c  **** 	{
 457:stk500boot.c  **** 		_delay_ms(0.5);
 458:stk500boot.c  **** 	}
 459:stk500boot.c  **** }
 460:stk500boot.c  **** 
 461:stk500boot.c  **** 
 462:stk500boot.c  **** //*****************************************************************************
 463:stk500boot.c  **** /*
 464:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 465:stk500boot.c  ****  */
 466:stk500boot.c  **** static void sendchar(char c)
 467:stk500boot.c  **** {
  15               		.loc 1 467 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 468:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 468 0
  23 0000 8093 CE00 		sts 206,r24
  24               	.LVL1:
  25               	.L2:
 469:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 469 0 discriminator 1
  27 0004 8091 C800 		lds r24,200
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 470:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 470 0
  31 000c 8091 C800 		lds r24,200
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C800 		sts 200,r24
  34               	.LVL2:
  35               	/* epilogue start */
 471:stk500boot.c  **** }
  36               		.loc 1 471 0
  37 0016 0895      		ret
  38               		.cfi_endproc
  39               	.LFE13:
  41               		.section	.text.unlikely,"ax",@progbits
  43               	recchar:
  44               	.LFB15:
 472:stk500boot.c  **** 
 473:stk500boot.c  **** 
 474:stk500boot.c  **** //************************************************************************
 475:stk500boot.c  **** static int	Serial_Available(void)
 476:stk500boot.c  **** {
 477:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 478:stk500boot.c  **** }
 479:stk500boot.c  **** 
 480:stk500boot.c  **** 
 481:stk500boot.c  **** //*****************************************************************************
 482:stk500boot.c  **** /*
 483:stk500boot.c  ****  * Read single byte from USART, block if no data available
 484:stk500boot.c  ****  */
 485:stk500boot.c  **** static unsigned char recchar(void)
 486:stk500boot.c  **** {
  45               		.loc 1 486 0
  46               		.cfi_startproc
  47               	/* prologue: function */
  48               	/* frame size = 0 */
  49               	/* stack size = 0 */
  50               	.L__stack_usage = 0
  51               	.L6:
 487:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
  52               		.loc 1 487 0 discriminator 1
  53 0000 8091 C800 		lds r24,200
  54 0004 87FF      		sbrs r24,7
  55 0006 00C0      		rjmp .L6
 488:stk500boot.c  **** 	{
 489:stk500boot.c  **** 		// wait for data
 490:stk500boot.c  **** 	}
 491:stk500boot.c  **** 	return UART_DATA_REG;
  56               		.loc 1 491 0
  57 0008 8091 CE00 		lds r24,206
  58               	/* epilogue start */
 492:stk500boot.c  **** }
  59               		.loc 1 492 0
  60 000c 0895      		ret
  61               		.cfi_endproc
  62               	.LFE15:
  64               		.section	.init9,"ax",@progbits
  65               	.global	__jumpMain
  67               	__jumpMain:
  68               	.LFB11:
 431:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  69               		.loc 1 431 0
  70               		.cfi_startproc
  71               	/* prologue: naked */
  72               	/* frame size = 0 */
  73               	/* stack size = 0 */
  74               	.L__stack_usage = 0
 435:stk500boot.c  **** 
  75               		.loc 1 435 0
  76               	/* #APP */
  77               	 ;  435 "stk500boot.c" 1
  78               		.set __stack, 8703
  79               	 ;  0 "" 2
 439:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  80               		.loc 1 439 0
  81               	 ;  439 "stk500boot.c" 1
  82 0000 01E2      		ldi	16, 33
  83               	 ;  0 "" 2
 440:stk500boot.c  **** 
  84               		.loc 1 440 0
  85               	 ;  440 "stk500boot.c" 1
  86 0002 0EBF      		out 62,16
  87               	 ;  0 "" 2
 442:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  88               		.loc 1 442 0
  89               	 ;  442 "stk500boot.c" 1
  90 0004 0FEF      		ldi	16, 255
  91               	 ;  0 "" 2
 443:stk500boot.c  **** 
  92               		.loc 1 443 0
  93               	 ;  443 "stk500boot.c" 1
  94 0006 0DBF      		out 61,16
  95               	 ;  0 "" 2
 445:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  96               		.loc 1 445 0
  97               	 ;  445 "stk500boot.c" 1
  98 0008 1124      		clr __zero_reg__
  99               	 ;  0 "" 2
 446:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 100               		.loc 1 446 0
 101               	 ;  446 "stk500boot.c" 1
 102 000a 1FBE      		out 63, __zero_reg__
 103               	 ;  0 "" 2
 447:stk500boot.c  **** }
 104               		.loc 1 447 0
 105               	 ;  447 "stk500boot.c" 1
 106 000c 0C94 0000 		jmp main
 107               	 ;  0 "" 2
 108               	/* epilogue start */
 448:stk500boot.c  **** 
 109               		.loc 1 448 0
 110               	/* #NOAPP */
 111               		.cfi_endproc
 112               	.LFE11:
 114               		.text
 115               	.global	delay_ms
 117               	delay_ms:
 118               	.LFB12:
 453:stk500boot.c  **** 	unsigned int i;
 119               		.loc 1 453 0
 120               		.cfi_startproc
 121               	.LVL3:
 122               	/* prologue: function */
 123               	/* frame size = 0 */
 124               	/* stack size = 0 */
 125               	.L__stack_usage = 0
 455:stk500boot.c  **** 	{
 126               		.loc 1 455 0
 127 0018 30E0      		ldi r19,0
 128 001a 20E0      		ldi r18,0
 129               	.LVL4:
 130               	.L10:
 455:stk500boot.c  **** 	{
 131               		.loc 1 455 0 is_stmt 0 discriminator 1
 132 001c 2817      		cp r18,r24
 133 001e 3907      		cpc r19,r25
 134 0020 01F4      		brne .L11
 135               	/* epilogue start */
 459:stk500boot.c  **** 
 136               		.loc 1 459 0 is_stmt 1
 137 0022 0895      		ret
 138               	.L11:
 139               	.LVL5:
 140               	.LBB77:
 141               	.LBB78:
 142               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 143               		.loc 2 187 0
 144 0024 EFEC      		ldi r30,lo8(1999)
 145 0026 F7E0      		ldi r31,hi8(1999)
 146 0028 3197      	1:	sbiw r30,1
 147 002a 01F4      		brne 1b
 148 002c 00C0      		rjmp .
 149 002e 0000      		nop
 150               	.LVL6:
 151               	.LBE78:
 152               	.LBE77:
 455:stk500boot.c  **** 	{
 153               		.loc 1 455 0
 154 0030 2F5F      		subi r18,-1
 155 0032 3F4F      		sbci r19,-1
 156               	.LVL7:
 157 0034 00C0      		rjmp .L10
 158               		.cfi_endproc
 159               	.LFE12:
 161               	.global	PrintFromPROGMEM
 163               	PrintFromPROGMEM:
 164               	.LFB18:
 493:stk500boot.c  **** 
 494:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 495:stk500boot.c  **** //*****************************************************************************
 496:stk500boot.c  **** static unsigned char recchar_timeout(void)
 497:stk500boot.c  **** {
 498:stk500boot.c  **** uint32_t count = 0;
 499:stk500boot.c  **** 
 500:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 501:stk500boot.c  **** 	{
 502:stk500boot.c  **** 		// wait for data
 503:stk500boot.c  **** 		count++;
 504:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 505:stk500boot.c  **** 		{
 506:stk500boot.c  **** 		unsigned int	data;
 507:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 508:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 509:stk500boot.c  **** 		#else
 510:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 511:stk500boot.c  **** 		#endif
 512:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 513:stk500boot.c  **** 			{
 514:stk500boot.c  **** 				asm volatile(
 515:stk500boot.c  **** 						"clr	r30		\n\t"
 516:stk500boot.c  **** 						"clr	r31		\n\t"
 517:stk500boot.c  **** 						"ijmp	\n\t"
 518:stk500boot.c  **** 						);
 519:stk500boot.c  **** 			}
 520:stk500boot.c  **** 			count	=	0;
 521:stk500boot.c  **** 		}
 522:stk500boot.c  **** 	}
 523:stk500boot.c  **** 	return UART_DATA_REG;
 524:stk500boot.c  **** }
 525:stk500boot.c  **** 
 526:stk500boot.c  **** //*	for watch dog timer startup
 527:stk500boot.c  **** void (*app_start)(void) = 0x0000;
 528:stk500boot.c  **** 
 529:stk500boot.c  **** 
 530:stk500boot.c  **** //*****************************************************************************
 531:stk500boot.c  **** int main(void)
 532:stk500boot.c  **** {
 533:stk500boot.c  **** 	address_t		address			=	0;
 534:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 535:stk500boot.c  **** 	unsigned char	msgParseState;
 536:stk500boot.c  **** 	unsigned int	ii				=	0;
 537:stk500boot.c  **** 	unsigned char	checksum		=	0;
 538:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 539:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 540:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 541:stk500boot.c  **** 	unsigned char	c, *p;
 542:stk500boot.c  **** 	unsigned char   isLeave = 0;
 543:stk500boot.c  **** 
 544:stk500boot.c  **** 	unsigned long	boot_timeout;
 545:stk500boot.c  **** 	unsigned long	boot_timer;
 546:stk500boot.c  **** 	unsigned int	boot_state;
 547:stk500boot.c  **** #ifdef ENABLE_MONITOR
 548:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 549:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 550:stk500boot.c  **** #endif
 551:stk500boot.c  **** 
 552:stk500boot.c  **** 	//*	some chips dont set the stack properly
 553:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 554:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 555:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 556:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 557:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 558:stk500boot.c  **** 
 559:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 560:stk500boot.c  **** 	//************************************************************************
 561:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 562:stk500boot.c  **** 	//*	handle the watch dog timer
 563:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 564:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 565:stk500boot.c  **** 
 566:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 567:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 568:stk500boot.c  **** 	MCUSR	=	0;
 569:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 570:stk500boot.c  **** 	WDTCSR	=	0;
 571:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 572:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 573:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 574:stk500boot.c  **** 	{
 575:stk500boot.c  **** 		app_start();
 576:stk500boot.c  **** 	}
 577:stk500boot.c  **** 	//************************************************************************
 578:stk500boot.c  **** #endif
 579:stk500boot.c  **** 
 580:stk500boot.c  **** 
 581:stk500boot.c  **** 	boot_timer	=	0;
 582:stk500boot.c  **** 	boot_state	=	0;
 583:stk500boot.c  **** 
 584:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 585:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 586:stk500boot.c  **** //	boot_timeout	=	170000;
 587:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 588:stk500boot.c  **** #else
 589:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 590:stk500boot.c  **** #endif
 591:stk500boot.c  **** 	/*
 592:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 593:stk500boot.c  **** 	 */
 594:stk500boot.c  **** 
 595:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 596:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 597:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 598:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 599:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 600:stk500boot.c  **** 
 601:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 602:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 603:stk500boot.c  **** 	{
 604:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 605:stk500boot.c  **** 		delay_ms(100);
 606:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 607:stk500boot.c  **** 		delay_ms(100);
 608:stk500boot.c  **** 	}
 609:stk500boot.c  **** #endif
 610:stk500boot.c  **** 
 611:stk500boot.c  **** #endif
 612:stk500boot.c  **** 	/*
 613:stk500boot.c  **** 	 * Init UART
 614:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 615:stk500boot.c  **** 	 */
 616:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 617:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 618:stk500boot.c  **** #endif
 619:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 620:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 621:stk500boot.c  **** 
 622:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 623:stk500boot.c  **** 
 624:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 625:stk500boot.c  **** //	delay_ms(500);
 626:stk500boot.c  **** 
 627:stk500boot.c  **** 	sendchar('s');
 628:stk500boot.c  **** 	sendchar('t');
 629:stk500boot.c  **** 	sendchar('k');
 630:stk500boot.c  **** //	sendchar('5');
 631:stk500boot.c  **** //	sendchar('0');
 632:stk500boot.c  **** //	sendchar('0');
 633:stk500boot.c  **** 	sendchar('v');
 634:stk500boot.c  **** 	sendchar('2');
 635:stk500boot.c  **** 	sendchar(0x0d);
 636:stk500boot.c  **** 	sendchar(0x0a);
 637:stk500boot.c  **** 
 638:stk500boot.c  **** 	delay_ms(100);
 639:stk500boot.c  **** #endif
 640:stk500boot.c  **** 
 641:stk500boot.c  **** 	while (boot_state==0)
 642:stk500boot.c  **** 	{
 643:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 644:stk500boot.c  **** 		{
 645:stk500boot.c  **** 			_delay_ms(0.001);
 646:stk500boot.c  **** 			boot_timer++;
 647:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 648:stk500boot.c  **** 			{
 649:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 650:stk500boot.c  **** 			}
 651:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 652:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 653:stk500boot.c  **** 			{
 654:stk500boot.c  **** 				//*	toggle the LED
 655:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 656:stk500boot.c  **** 			}
 657:stk500boot.c  **** 		#endif
 658:stk500boot.c  **** 		}
 659:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 660:stk500boot.c  **** 	}
 661:stk500boot.c  **** 
 662:stk500boot.c  **** 
 663:stk500boot.c  **** 	if (boot_state==1)
 664:stk500boot.c  **** 	{
 665:stk500boot.c  **** 		//*	main loop
 666:stk500boot.c  **** 		while (!isLeave)
 667:stk500boot.c  **** 		{
 668:stk500boot.c  **** 			/*
 669:stk500boot.c  **** 			 * Collect received bytes to a complete message
 670:stk500boot.c  **** 			 */
 671:stk500boot.c  **** 			msgParseState	=	ST_START;
 672:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 673:stk500boot.c  **** 			{
 674:stk500boot.c  **** 				if (boot_state==1)
 675:stk500boot.c  **** 				{
 676:stk500boot.c  **** 					boot_state	=	0;
 677:stk500boot.c  **** 					c			=	UART_DATA_REG;
 678:stk500boot.c  **** 				}
 679:stk500boot.c  **** 				else
 680:stk500boot.c  **** 				{
 681:stk500boot.c  **** 				//	c	=	recchar();
 682:stk500boot.c  **** 					c	=	recchar_timeout();
 683:stk500boot.c  **** 					
 684:stk500boot.c  **** 				}
 685:stk500boot.c  **** 
 686:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 687:stk500boot.c  **** 				rcvdCharCntr++;
 688:stk500boot.c  **** 
 689:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 690:stk500boot.c  **** 				{
 691:stk500boot.c  **** 					exPointCntr++;
 692:stk500boot.c  **** 					if (exPointCntr == 3)
 693:stk500boot.c  **** 					{
 694:stk500boot.c  **** 						RunMonitor();
 695:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 696:stk500boot.c  **** 						isLeave			=	1;
 697:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 698:stk500boot.c  **** 						break;
 699:stk500boot.c  **** 					}
 700:stk500boot.c  **** 				}
 701:stk500boot.c  **** 				else
 702:stk500boot.c  **** 				{
 703:stk500boot.c  **** 					exPointCntr	=	0;
 704:stk500boot.c  **** 				}
 705:stk500boot.c  **** 			#endif
 706:stk500boot.c  **** 
 707:stk500boot.c  **** 				switch (msgParseState)
 708:stk500boot.c  **** 				{
 709:stk500boot.c  **** 					case ST_START:
 710:stk500boot.c  **** 						if ( c == MESSAGE_START )
 711:stk500boot.c  **** 						{
 712:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 713:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 714:stk500boot.c  **** 						}
 715:stk500boot.c  **** 						break;
 716:stk500boot.c  **** 
 717:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 718:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 719:stk500boot.c  **** 						seqNum			=	c;
 720:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 721:stk500boot.c  **** 						checksum		^=	c;
 722:stk500boot.c  **** 					#else
 723:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 724:stk500boot.c  **** 						{
 725:stk500boot.c  **** 							seqNum			=	c;
 726:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 727:stk500boot.c  **** 							checksum		^=	c;
 728:stk500boot.c  **** 						}
 729:stk500boot.c  **** 						else
 730:stk500boot.c  **** 						{
 731:stk500boot.c  **** 							msgParseState	=	ST_START;
 732:stk500boot.c  **** 						}
 733:stk500boot.c  **** 					#endif
 734:stk500boot.c  **** 						break;
 735:stk500boot.c  **** 
 736:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 737:stk500boot.c  **** 						msgLength		=	c<<8;
 738:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 739:stk500boot.c  **** 						checksum		^=	c;
 740:stk500boot.c  **** 						break;
 741:stk500boot.c  **** 
 742:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 743:stk500boot.c  **** 						msgLength		|=	c;
 744:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 745:stk500boot.c  **** 						checksum		^=	c;
 746:stk500boot.c  **** 						break;
 747:stk500boot.c  **** 
 748:stk500boot.c  **** 					case ST_GET_TOKEN:
 749:stk500boot.c  **** 						if ( c == TOKEN )
 750:stk500boot.c  **** 						{
 751:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 752:stk500boot.c  **** 							checksum		^=	c;
 753:stk500boot.c  **** 							ii				=	0;
 754:stk500boot.c  **** 						}
 755:stk500boot.c  **** 						else
 756:stk500boot.c  **** 						{
 757:stk500boot.c  **** 							msgParseState	=	ST_START;
 758:stk500boot.c  **** 						}
 759:stk500boot.c  **** 						break;
 760:stk500boot.c  **** 
 761:stk500boot.c  **** 					case ST_GET_DATA:
 762:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 763:stk500boot.c  **** 						checksum		^=	c;
 764:stk500boot.c  **** 						if (ii == msgLength )
 765:stk500boot.c  **** 						{
 766:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 767:stk500boot.c  **** 						}
 768:stk500boot.c  **** 						break;
 769:stk500boot.c  **** 
 770:stk500boot.c  **** 					case ST_GET_CHECK:
 771:stk500boot.c  **** 						if ( c == checksum )
 772:stk500boot.c  **** 						{
 773:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 774:stk500boot.c  **** 						}
 775:stk500boot.c  **** 						else
 776:stk500boot.c  **** 						{
 777:stk500boot.c  **** 							msgParseState	=	ST_START;
 778:stk500boot.c  **** 						}
 779:stk500boot.c  **** 						break;
 780:stk500boot.c  **** 				}	//	switch
 781:stk500boot.c  **** 			}	//	while(msgParseState)
 782:stk500boot.c  **** 
 783:stk500boot.c  **** 			/*
 784:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 785:stk500boot.c  **** 			 */
 786:stk500boot.c  **** 
 787:stk500boot.c  **** 			switch (msgBuffer[0])
 788:stk500boot.c  **** 			{
 789:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 790:stk500boot.c  **** 				case CMD_SPI_MULTI:
 791:stk500boot.c  **** 					{
 792:stk500boot.c  **** 						unsigned char answerByte;
 793:stk500boot.c  **** 						unsigned char flag=0;
 794:stk500boot.c  **** 
 795:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 796:stk500boot.c  **** 						{
 797:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 798:stk500boot.c  **** 
 799:stk500boot.c  **** 							if ( signatureIndex == 0 )
 800:stk500boot.c  **** 							{
 801:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 802:stk500boot.c  **** 							}
 803:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 804:stk500boot.c  **** 							{
 805:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 806:stk500boot.c  **** 							}
 807:stk500boot.c  **** 							else
 808:stk500boot.c  **** 							{
 809:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 810:stk500boot.c  **** 							}
 811:stk500boot.c  **** 						}
 812:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 813:stk500boot.c  **** 						{
 814:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 815:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 816:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 817:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 818:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 819:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 820:stk500boot.c  **** 							{
 821:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 822:stk500boot.c  **** 							}
 823:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 824:stk500boot.c  **** 							{
 825:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 826:stk500boot.c  **** 							}
 827:stk500boot.c  **** 							else
 828:stk500boot.c  **** 							{
 829:stk500boot.c  **** 								answerByte	=	0;
 830:stk500boot.c  **** 							}
 831:stk500boot.c  **** 						}
 832:stk500boot.c  **** 						else
 833:stk500boot.c  **** 						{
 834:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 835:stk500boot.c  **** 						}
 836:stk500boot.c  **** 						if ( !flag )
 837:stk500boot.c  **** 						{
 838:stk500boot.c  **** 							msgLength		=	7;
 839:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 840:stk500boot.c  **** 							msgBuffer[2]	=	0;
 841:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 842:stk500boot.c  **** 							msgBuffer[4]	=	0;
 843:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 844:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 845:stk500boot.c  **** 						}
 846:stk500boot.c  **** 					}
 847:stk500boot.c  **** 					break;
 848:stk500boot.c  **** 	#endif
 849:stk500boot.c  **** 				case CMD_SIGN_ON:
 850:stk500boot.c  **** 					msgLength		=	11;
 851:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 852:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 853:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 854:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 855:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 856:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 857:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 858:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 859:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 860:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 861:stk500boot.c  **** 					break;
 862:stk500boot.c  **** 
 863:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 864:stk500boot.c  **** 					{
 865:stk500boot.c  **** 						unsigned char value;
 866:stk500boot.c  **** 
 867:stk500boot.c  **** 						switch(msgBuffer[1])
 868:stk500boot.c  **** 						{
 869:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 870:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 871:stk500boot.c  **** 							break;
 872:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 873:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 874:stk500boot.c  **** 							break;
 875:stk500boot.c  **** 						case PARAM_HW_VER:
 876:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 877:stk500boot.c  **** 							break;
 878:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 879:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 880:stk500boot.c  **** 							break;
 881:stk500boot.c  **** 						case PARAM_SW_MINOR:
 882:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 883:stk500boot.c  **** 							break;
 884:stk500boot.c  **** 						default:
 885:stk500boot.c  **** 							value	=	0;
 886:stk500boot.c  **** 							break;
 887:stk500boot.c  **** 						}
 888:stk500boot.c  **** 						msgLength		=	3;
 889:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 890:stk500boot.c  **** 						msgBuffer[2]	=	value;
 891:stk500boot.c  **** 					}
 892:stk500boot.c  **** 					break;
 893:stk500boot.c  **** 
 894:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 895:stk500boot.c  **** 					isLeave	=	1;
 896:stk500boot.c  **** 					//*	fall thru
 897:stk500boot.c  **** 
 898:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 899:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 900:stk500boot.c  **** 					msgLength		=	2;
 901:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 902:stk500boot.c  **** 					break;
 903:stk500boot.c  **** 
 904:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 905:stk500boot.c  **** 					{
 906:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 907:stk500boot.c  **** 						unsigned char signature;
 908:stk500boot.c  **** 
 909:stk500boot.c  **** 						if ( signatureIndex == 0 )
 910:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 911:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 912:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 913:stk500boot.c  **** 						else
 914:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 915:stk500boot.c  **** 
 916:stk500boot.c  **** 						msgLength		=	4;
 917:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 918:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 919:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 920:stk500boot.c  **** 					}
 921:stk500boot.c  **** 					break;
 922:stk500boot.c  **** 
 923:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
 924:stk500boot.c  **** 					msgLength		=	4;
 925:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 926:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 927:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 928:stk500boot.c  **** 					break;
 929:stk500boot.c  **** 
 930:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
 931:stk500boot.c  **** 					{
 932:stk500boot.c  **** 						unsigned char fuseBits;
 933:stk500boot.c  **** 
 934:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 935:stk500boot.c  **** 						{
 936:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 937:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 938:stk500boot.c  **** 							else
 939:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 940:stk500boot.c  **** 						}
 941:stk500boot.c  **** 						else
 942:stk500boot.c  **** 						{
 943:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 944:stk500boot.c  **** 						}
 945:stk500boot.c  **** 						msgLength		=	4;
 946:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 947:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 948:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 949:stk500boot.c  **** 					}
 950:stk500boot.c  **** 					break;
 951:stk500boot.c  **** 
 952:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 953:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
 954:stk500boot.c  **** 					{
 955:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
 956:stk500boot.c  **** 
 957:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 958:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 959:stk500boot.c  **** 						boot_spm_busy_wait();
 960:stk500boot.c  **** 
 961:stk500boot.c  **** 						msgLength		=	3;
 962:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 963:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 964:stk500boot.c  **** 					}
 965:stk500boot.c  **** 					break;
 966:stk500boot.c  **** 	#endif
 967:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
 968:stk500boot.c  **** 					eraseAddress	=	0;
 969:stk500boot.c  **** 					msgLength		=	2;
 970:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 971:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 972:stk500boot.c  **** 					break;
 973:stk500boot.c  **** 
 974:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
 975:stk500boot.c  **** 	#if defined(RAMPZ)
 976:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 977:stk500boot.c  **** 	#else
 978:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
 979:stk500boot.c  **** 	#endif
 980:stk500boot.c  **** 					msgLength		=	2;
 981:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 982:stk500boot.c  **** 					break;
 983:stk500boot.c  **** 
 984:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
 985:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
 986:stk500boot.c  **** 					{
 987:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 988:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 989:stk500boot.c  **** 						unsigned int	data;
 990:stk500boot.c  **** 						unsigned char	highByte, lowByte;
 991:stk500boot.c  **** 						address_t		tempaddress	=	address;
 992:stk500boot.c  **** 
 993:stk500boot.c  **** 
 994:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 995:stk500boot.c  **** 						{
 996:stk500boot.c  **** 							// erase only main section (bootloader protection)
 997:stk500boot.c  **** 							if (eraseAddress < APP_END )
 998:stk500boot.c  **** 							{
 999:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1000:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1001:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1002:stk500boot.c  **** 							}
1003:stk500boot.c  **** 
1004:stk500boot.c  **** 							/* Write FLASH */
1005:stk500boot.c  **** 							do {
1006:stk500boot.c  **** 								lowByte		=	*p++;
1007:stk500boot.c  **** 								highByte 	=	*p++;
1008:stk500boot.c  **** 
1009:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1010:stk500boot.c  **** 								boot_page_fill(address,data);
1011:stk500boot.c  **** 
1012:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1013:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1014:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1015:stk500boot.c  **** 
1016:stk500boot.c  **** 							boot_page_write(tempaddress);
1017:stk500boot.c  **** 							boot_spm_busy_wait();
1018:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1019:stk500boot.c  **** 						}
1020:stk500boot.c  **** 						else
1021:stk500boot.c  **** 						{
1022:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1023:stk500boot.c  **** 							uint16_t ii = address >> 1;
1024:stk500boot.c  **** 							/* write EEPROM */
1025:stk500boot.c  **** 							while (size) {
1026:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1027:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1028:stk500boot.c  **** 								ii++;
1029:stk500boot.c  **** 								size--;
1030:stk500boot.c  **** 							}
1031:stk500boot.c  **** 						}
1032:stk500boot.c  **** 						msgLength		=	2;
1033:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1034:stk500boot.c  **** 					}
1035:stk500boot.c  **** 					break;
1036:stk500boot.c  **** 
1037:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1038:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1039:stk500boot.c  **** 					{
1040:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1041:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1042:stk500boot.c  **** 						msgLength				=	size+3;
1043:stk500boot.c  **** 
1044:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1045:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1046:stk500boot.c  **** 						{
1047:stk500boot.c  **** 							unsigned int data;
1048:stk500boot.c  **** 
1049:stk500boot.c  **** 							// Read FLASH
1050:stk500boot.c  **** 							do {
1051:stk500boot.c  **** 						//#if defined(RAMPZ)
1052:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1053:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1054:stk500boot.c  **** 						#else
1055:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1056:stk500boot.c  **** 						#endif
1057:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1058:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1059:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1060:stk500boot.c  **** 								size	-=	2;
1061:stk500boot.c  **** 							}while (size);
1062:stk500boot.c  **** 						}
1063:stk500boot.c  **** 						else
1064:stk500boot.c  **** 						{
1065:stk500boot.c  **** 							/* Read EEPROM */
1066:stk500boot.c  **** 							do {
1067:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1068:stk500boot.c  **** 								EEARH	=	((address >> 8));
1069:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1070:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1071:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1072:stk500boot.c  **** 								size--;
1073:stk500boot.c  **** 							} while (size);
1074:stk500boot.c  **** 						}
1075:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1076:stk500boot.c  **** 					}
1077:stk500boot.c  **** 					break;
1078:stk500boot.c  **** 
1079:stk500boot.c  **** 				default:
1080:stk500boot.c  **** 					msgLength		=	2;
1081:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1082:stk500boot.c  **** 					break;
1083:stk500boot.c  **** 			}
1084:stk500boot.c  **** 
1085:stk500boot.c  **** 			/*
1086:stk500boot.c  **** 			 * Now send answer message back
1087:stk500boot.c  **** 			 */
1088:stk500boot.c  **** 			sendchar(MESSAGE_START);
1089:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1090:stk500boot.c  **** 
1091:stk500boot.c  **** 			sendchar(seqNum);
1092:stk500boot.c  **** 			checksum	^=	seqNum;
1093:stk500boot.c  **** 
1094:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1095:stk500boot.c  **** 			sendchar(c);
1096:stk500boot.c  **** 			checksum	^=	c;
1097:stk500boot.c  **** 
1098:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1099:stk500boot.c  **** 			sendchar(c);
1100:stk500boot.c  **** 			checksum ^= c;
1101:stk500boot.c  **** 
1102:stk500boot.c  **** 			sendchar(TOKEN);
1103:stk500boot.c  **** 			checksum ^= TOKEN;
1104:stk500boot.c  **** 
1105:stk500boot.c  **** 			p	=	msgBuffer;
1106:stk500boot.c  **** 			while ( msgLength )
1107:stk500boot.c  **** 			{
1108:stk500boot.c  **** 				c	=	*p++;
1109:stk500boot.c  **** 				sendchar(c);
1110:stk500boot.c  **** 				checksum ^=c;
1111:stk500boot.c  **** 				msgLength--;
1112:stk500boot.c  **** 			}
1113:stk500boot.c  **** 			sendchar(checksum);
1114:stk500boot.c  **** 			seqNum++;
1115:stk500boot.c  **** 	
1116:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1117:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1118:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1119:stk500boot.c  **** 		#endif
1120:stk500boot.c  **** 
1121:stk500boot.c  **** 		}
1122:stk500boot.c  **** 	}
1123:stk500boot.c  **** 
1124:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1125:stk500boot.c  **** 	//*	this is for debugging it can be removed
1126:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1127:stk500boot.c  **** 	{
1128:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1129:stk500boot.c  **** 		delay_ms(200);
1130:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1131:stk500boot.c  **** 		delay_ms(200);
1132:stk500boot.c  **** 	}
1133:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1134:stk500boot.c  **** #endif
1135:stk500boot.c  **** 
1136:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1137:stk500boot.c  **** 	sendchar('j');
1138:stk500boot.c  **** //	sendchar('u');
1139:stk500boot.c  **** //	sendchar('m');
1140:stk500boot.c  **** //	sendchar('p');
1141:stk500boot.c  **** //	sendchar(' ');
1142:stk500boot.c  **** //	sendchar('u');
1143:stk500boot.c  **** //	sendchar('s');
1144:stk500boot.c  **** //	sendchar('r');
1145:stk500boot.c  **** 	sendchar(0x0d);
1146:stk500boot.c  **** 	sendchar(0x0a);
1147:stk500boot.c  **** 
1148:stk500boot.c  **** 	delay_ms(100);
1149:stk500boot.c  **** #endif
1150:stk500boot.c  **** 
1151:stk500boot.c  **** 
1152:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1153:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1154:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1155:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1156:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1157:stk500boot.c  **** #endif
1158:stk500boot.c  **** 
1159:stk500boot.c  **** 
1160:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1161:stk500boot.c  **** 
1162:stk500boot.c  **** 	/*
1163:stk500boot.c  **** 	 * Now leave bootloader
1164:stk500boot.c  **** 	 */
1165:stk500boot.c  **** 
1166:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1167:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1168:stk500boot.c  **** 
1169:stk500boot.c  **** 
1170:stk500boot.c  **** 	asm volatile(
1171:stk500boot.c  **** 			"clr	r30		\n\t"
1172:stk500boot.c  **** 			"clr	r31		\n\t"
1173:stk500boot.c  **** 			"ijmp	\n\t"
1174:stk500boot.c  **** 			);
1175:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1176:stk500boot.c  **** //					"push r1" "\n\t"
1177:stk500boot.c  **** //					"ret"	 "\n\t"
1178:stk500boot.c  **** //					::);
1179:stk500boot.c  **** 
1180:stk500boot.c  **** 	 /*
1181:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1182:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1183:stk500boot.c  **** 	 * understand this
1184:stk500boot.c  **** 	 */
1185:stk500boot.c  **** 	for(;;);
1186:stk500boot.c  **** }
1187:stk500boot.c  **** 
1188:stk500boot.c  **** /*
1189:stk500boot.c  **** base address = f800
1190:stk500boot.c  **** 
1191:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1192:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1193:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1194:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1195:stk500boot.c  **** avrdude>
1196:stk500boot.c  **** 
1197:stk500boot.c  **** 
1198:stk500boot.c  **** base address = f000
1199:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1200:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1201:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1202:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1203:stk500boot.c  **** avrdude>
1204:stk500boot.c  **** */
1205:stk500boot.c  **** 
1206:stk500boot.c  **** //************************************************************************
1207:stk500boot.c  **** #ifdef ENABLE_MONITOR
1208:stk500boot.c  **** #include	<math.h>
1209:stk500boot.c  **** 
1210:stk500boot.c  **** unsigned long	gRamIndex;
1211:stk500boot.c  **** unsigned long	gFlashIndex;
1212:stk500boot.c  **** unsigned long	gEepromIndex;
1213:stk500boot.c  **** 
1214:stk500boot.c  **** 
1215:stk500boot.c  **** #define	true	1
1216:stk500boot.c  **** #define	false	0
1217:stk500boot.c  **** 
1218:stk500boot.c  **** #include	"avr_cpunames.h"
1219:stk500boot.c  **** 
1220:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1221:stk500boot.c  **** 	#error cpu name not defined
1222:stk500boot.c  **** #endif
1223:stk500boot.c  **** 
1224:stk500boot.c  **** #ifdef _VECTORS_SIZE
1225:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1226:stk500boot.c  **** #else
1227:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1228:stk500boot.c  **** #endif
1229:stk500boot.c  **** 
1230:stk500boot.c  **** 
1231:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1232:stk500boot.c  **** 
1233:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1234:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1235:stk500boot.c  **** #else
1236:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1237:stk500boot.c  **** #endif
1238:stk500boot.c  **** 
1239:stk500boot.c  **** 	const char	gTextMsg_Explorer[]			PROGMEM	=	"Arduino explorer stk500V2 by MLS";
1240:stk500boot.c  **** 	const char	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1241:stk500boot.c  **** 	const char	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1242:stk500boot.c  **** 	const char	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1243:stk500boot.c  **** 	const char	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1244:stk500boot.c  **** 	const char	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1245:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1246:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1247:stk500boot.c  **** 	const char	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1248:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1249:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1250:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1251:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1252:stk500boot.c  **** 	const char	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1253:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1254:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1255:stk500boot.c  **** 	const char	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Interrup
1256:stk500boot.c  **** 	const char	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1257:stk500boot.c  **** 	const char	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1258:stk500boot.c  **** 	const char	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1259:stk500boot.c  **** 	const char	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1260:stk500boot.c  **** 	const char	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1261:stk500boot.c  **** 	const char	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1262:stk500boot.c  **** 	const char	gTextMsg_SPACE[]			PROGMEM	=	" ";
1263:stk500boot.c  **** 	const char	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writting EE";
1264:stk500boot.c  **** 	const char	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1265:stk500boot.c  **** 	const char	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1266:stk500boot.c  **** 	const char	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1267:stk500boot.c  **** 
1268:stk500boot.c  **** 
1269:stk500boot.c  **** //************************************************************************
1270:stk500boot.c  **** //*	Help messages
1271:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1272:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1273:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1274:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1275:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1276:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1277:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1278:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1279:stk500boot.c  **** //	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit & jump to user pgm";
1280:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1281:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1282:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1283:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1284:stk500boot.c  **** 
1285:stk500boot.c  **** 	const char	gTextMsg_END[]				PROGMEM	=	"*";
1286:stk500boot.c  **** 
1287:stk500boot.c  **** 
1288:stk500boot.c  **** //************************************************************************
1289:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1290:stk500boot.c  **** {
 165               		.loc 1 1290 0
 166               		.cfi_startproc
 167               	.LVL8:
 168 0036 CF93      		push r28
 169               	.LCFI0:
 170               		.cfi_def_cfa_offset 4
 171               		.cfi_offset 28, -3
 172 0038 DF93      		push r29
 173               	.LCFI1:
 174               		.cfi_def_cfa_offset 5
 175               		.cfi_offset 29, -4
 176               	/* prologue: function */
 177               	/* frame size = 0 */
 178               	/* stack size = 2 */
 179               	.L__stack_usage = 2
1291:stk500boot.c  **** char	theChar;
1292:stk500boot.c  **** 
1293:stk500boot.c  **** 	dataPtr		+=	offset;
 180               		.loc 1 1293 0
 181 003a EC01      		movw r28,r24
 182 003c C60F      		add r28,r22
 183 003e D11D      		adc r29,__zero_reg__
 184               	.LVL9:
 185               	.L14:
 186               	.LBB79:
1294:stk500boot.c  **** 
1295:stk500boot.c  **** 	do {
1296:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1297:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 187               		.loc 1 1297 0
 188 0040 CE01      		movw r24,r28
 189 0042 B0E0      		ldi r27,0
 190 0044 A0E0      		ldi r26,0
 191               	/* #APP */
 192               	 ;  1297 "stk500boot.c" 1
 193 0046 ABBF      		out 59, r26
 194 0048 FC01      		movw r30, r24
 195 004a 8791      		elpm r24, Z+
 196               		
 197               	 ;  0 "" 2
 198               	.LVL10:
 199               	/* #NOAPP */
 200               	.LBE79:
1298:stk500boot.c  **** 	#else
1299:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1300:stk500boot.c  **** 	#endif
1301:stk500boot.c  **** 		if (theChar != 0)
 201               		.loc 1 1301 0
 202 004c 8823      		tst r24
 203 004e 01F0      		breq .L12
 204               	.LBB80:
1297:stk500boot.c  **** 	#else
 205               		.loc 1 1297 0
 206 0050 2196      		adiw r28,1
 207               	.LVL11:
 208               	.LBE80:
1302:stk500boot.c  **** 		{
1303:stk500boot.c  **** 			sendchar(theChar);
 209               		.loc 1 1303 0
 210 0052 0E94 0000 		call sendchar
 211               	.LVL12:
 212 0056 00C0      		rjmp .L14
 213               	.LVL13:
 214               	.L12:
 215               	/* epilogue start */
1304:stk500boot.c  **** 		}
1305:stk500boot.c  **** 	} while (theChar != 0);
1306:stk500boot.c  **** }
 216               		.loc 1 1306 0
 217 0058 DF91      		pop r29
 218 005a CF91      		pop r28
 219               	.LVL14:
 220 005c 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	PrintNewLine
 226               	PrintNewLine:
 227               	.LFB19:
1307:stk500boot.c  **** 
1308:stk500boot.c  **** //************************************************************************
1309:stk500boot.c  **** void	PrintNewLine(void)
1310:stk500boot.c  **** {
 228               		.loc 1 1310 0
 229               		.cfi_startproc
 230               	/* prologue: function */
 231               	/* frame size = 0 */
 232               	/* stack size = 0 */
 233               	.L__stack_usage = 0
1311:stk500boot.c  **** 	sendchar(0x0d);
 234               		.loc 1 1311 0
 235 005e 8DE0      		ldi r24,lo8(13)
 236 0060 0E94 0000 		call sendchar
 237               	.LVL15:
1312:stk500boot.c  **** 	sendchar(0x0a);
 238               		.loc 1 1312 0
 239 0064 8AE0      		ldi r24,lo8(10)
 240 0066 0C94 0000 		jmp sendchar
 241               	.LVL16:
 242               		.cfi_endproc
 243               	.LFE19:
 245               		.section	.text.unlikely
 247               	PrintAvailablePort:
 248               	.LFB29:
1313:stk500boot.c  **** }
1314:stk500boot.c  **** 
1315:stk500boot.c  **** 
1316:stk500boot.c  **** //************************************************************************
1317:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1318:stk500boot.c  **** {
1319:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
1320:stk500boot.c  **** 
1321:stk500boot.c  **** 	PrintNewLine();
1322:stk500boot.c  **** }
1323:stk500boot.c  **** 
1324:stk500boot.c  **** 
1325:stk500boot.c  **** //************************************************************************
1326:stk500boot.c  **** void	PrintString(char *textString)
1327:stk500boot.c  **** {
1328:stk500boot.c  **** char	theChar;
1329:stk500boot.c  **** int		ii;
1330:stk500boot.c  **** 
1331:stk500boot.c  **** 	theChar		=	1;
1332:stk500boot.c  **** 	ii			=	0;
1333:stk500boot.c  **** 	while (theChar != 0)
1334:stk500boot.c  **** 	{
1335:stk500boot.c  **** 		theChar	=	textString[ii];
1336:stk500boot.c  **** 		if (theChar != 0)
1337:stk500boot.c  **** 		{
1338:stk500boot.c  **** 			sendchar(theChar);
1339:stk500boot.c  **** 		}
1340:stk500boot.c  **** 		ii++;
1341:stk500boot.c  **** 	}
1342:stk500boot.c  **** }
1343:stk500boot.c  **** 
1344:stk500boot.c  **** //************************************************************************
1345:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1346:stk500boot.c  **** {
1347:stk500boot.c  **** char	theChar;
1348:stk500boot.c  **** 
1349:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1350:stk500boot.c  **** 	if (theChar > 0x39)
1351:stk500boot.c  **** 	{
1352:stk500boot.c  **** 		theChar	+=	7;
1353:stk500boot.c  **** 	}
1354:stk500boot.c  **** 	sendchar(theChar );
1355:stk500boot.c  **** 
1356:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1357:stk500boot.c  **** 	if (theChar > 0x39)
1358:stk500boot.c  **** 	{
1359:stk500boot.c  **** 		theChar	+=	7;
1360:stk500boot.c  **** 	}
1361:stk500boot.c  **** 	sendchar(theChar );
1362:stk500boot.c  **** }
1363:stk500boot.c  **** 
1364:stk500boot.c  **** //************************************************************************
1365:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1366:stk500boot.c  **** {
1367:stk500boot.c  **** int	theChar;
1368:stk500boot.c  **** int	myNumber;
1369:stk500boot.c  **** 
1370:stk500boot.c  **** 	myNumber	=	theNumber;
1371:stk500boot.c  **** 
1372:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1373:stk500boot.c  **** 	{
1374:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
1375:stk500boot.c  **** 		sendchar(theChar );
1376:stk500boot.c  **** 	}
1377:stk500boot.c  **** 
1378:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1379:stk500boot.c  **** 	{
1380:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
1381:stk500boot.c  **** 		sendchar(theChar );
1382:stk500boot.c  **** 	}
1383:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
1384:stk500boot.c  **** 	sendchar(theChar );
1385:stk500boot.c  **** }
1386:stk500boot.c  **** 
1387:stk500boot.c  **** 
1388:stk500boot.c  **** 
1389:stk500boot.c  **** 
1390:stk500boot.c  **** //************************************************************************
1391:stk500boot.c  **** static void	PrintCPUstats(void)
1392:stk500boot.c  **** {
1393:stk500boot.c  **** unsigned char fuseByte;
1394:stk500boot.c  **** 
1395:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
1396:stk500boot.c  **** 
1397:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
1398:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
1399:stk500boot.c  **** 
1400:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
1401:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1402:stk500boot.c  **** 
1403:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
1404:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1405:stk500boot.c  **** 	PrintNewLine();
1406:stk500boot.c  **** 
1407:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
1408:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
1409:stk500boot.c  **** 
1410:stk500boot.c  **** 	//*	these can be found in avr/version.h
1411:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
1412:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
1413:stk500boot.c  **** 
1414:stk500boot.c  **** #if defined(SIGNATURE_0)
1415:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
1416:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1417:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1418:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1419:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1420:stk500boot.c  **** 	PrintNewLine();
1421:stk500boot.c  **** #endif
1422:stk500boot.c  **** 
1423:stk500boot.c  **** 
1424:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1425:stk500boot.c  **** 	//*	fuse settings
1426:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
1427:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1428:stk500boot.c  **** 	PrintHexByte(fuseByte);
1429:stk500boot.c  **** 	PrintNewLine();
1430:stk500boot.c  **** 
1431:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
1432:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1433:stk500boot.c  **** 	PrintHexByte(fuseByte);
1434:stk500boot.c  **** 	PrintNewLine();
1435:stk500boot.c  **** 
1436:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
1437:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1438:stk500boot.c  **** 	PrintHexByte(fuseByte);
1439:stk500boot.c  **** 	PrintNewLine();
1440:stk500boot.c  **** 
1441:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
1442:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1443:stk500boot.c  **** 	PrintHexByte(fuseByte);
1444:stk500boot.c  **** 	PrintNewLine();
1445:stk500boot.c  **** 
1446:stk500boot.c  **** #endif
1447:stk500boot.c  **** 
1448:stk500boot.c  **** }
1449:stk500boot.c  **** 
1450:stk500boot.c  **** 
1451:stk500boot.c  **** //************************************************************************
1452:stk500boot.c  **** static void BlinkLED(void)
1453:stk500boot.c  **** {
1454:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
1455:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
1456:stk500boot.c  **** 
1457:stk500boot.c  **** 	while (!Serial_Available())
1458:stk500boot.c  **** 	{
1459:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1460:stk500boot.c  **** 		delay_ms(100);
1461:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1462:stk500boot.c  **** 		delay_ms(100);
1463:stk500boot.c  **** 	}
1464:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1465:stk500boot.c  **** }
1466:stk500boot.c  **** 
1467:stk500boot.c  **** enum
1468:stk500boot.c  **** {
1469:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1470:stk500boot.c  **** 	kDUMP_EEPROM,
1471:stk500boot.c  **** 	kDUMP_RAM
1472:stk500boot.c  **** };
1473:stk500boot.c  **** 
1474:stk500boot.c  **** //************************************************************************
1475:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
1476:stk500boot.c  **** {
1477:stk500boot.c  **** unsigned long	myAddressPointer;
1478:stk500boot.c  **** uint8_t			ii;
1479:stk500boot.c  **** unsigned char	theValue;
1480:stk500boot.c  **** char			asciiDump[18];
1481:stk500boot.c  **** unsigned char	*ramPtr;
1482:stk500boot.c  **** 
1483:stk500boot.c  **** 
1484:stk500boot.c  **** 	ramPtr				=	0;
1485:stk500boot.c  **** 	theValue			=	0;
1486:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1487:stk500boot.c  **** 	while (numRows > 0)
1488:stk500boot.c  **** 	{
1489:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1490:stk500boot.c  **** 		{
1491:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1492:stk500boot.c  **** 		}
1493:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1494:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1495:stk500boot.c  **** 		sendchar(0x20);
1496:stk500boot.c  **** 		sendchar('-');
1497:stk500boot.c  **** 		sendchar(0x20);
1498:stk500boot.c  **** 
1499:stk500boot.c  **** 		asciiDump[0]		=	0;
1500:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
1501:stk500boot.c  **** 		{
1502:stk500boot.c  **** 			switch(dumpWhat)
1503:stk500boot.c  **** 			{
1504:stk500boot.c  **** 				case kDUMP_FLASH:
1505:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1506:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1507:stk500boot.c  **** 				#else
1508:stk500boot.c  **** 					theValue	=	pgm_read_byte_near(myAddressPointer);
1509:stk500boot.c  **** 				#endif
1510:stk500boot.c  **** 					break;
1511:stk500boot.c  **** 
1512:stk500boot.c  **** 				case kDUMP_EEPROM:
1513:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1514:stk500boot.c  **** 					break;
1515:stk500boot.c  **** 
1516:stk500boot.c  **** 				case kDUMP_RAM:
1517:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1518:stk500boot.c  **** 					break;
1519:stk500boot.c  **** 
1520:stk500boot.c  **** 			}
1521:stk500boot.c  **** 			PrintHexByte(theValue);
1522:stk500boot.c  **** 			sendchar(0x20);
1523:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1524:stk500boot.c  **** 			{
1525:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1526:stk500boot.c  **** 			}
1527:stk500boot.c  **** 			else
1528:stk500boot.c  **** 			{
1529:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1530:stk500boot.c  **** 			}
1531:stk500boot.c  **** 
1532:stk500boot.c  **** 			myAddressPointer++;
1533:stk500boot.c  **** 		}
1534:stk500boot.c  **** 		asciiDump[16]	=	0;
1535:stk500boot.c  **** 		PrintString(asciiDump);
1536:stk500boot.c  **** 		PrintNewLine();
1537:stk500boot.c  **** 
1538:stk500boot.c  **** 		numRows--;
1539:stk500boot.c  **** 	}
1540:stk500boot.c  **** }
1541:stk500boot.c  **** 
1542:stk500boot.c  **** 
1543:stk500boot.c  **** 
1544:stk500boot.c  **** //************************************************************************
1545:stk500boot.c  **** //*	returns amount of extended memory
1546:stk500boot.c  **** static void	EEPROMtest(void)
1547:stk500boot.c  **** {
1548:stk500boot.c  **** int		ii;
1549:stk500boot.c  **** char	theChar;
1550:stk500boot.c  **** char	theEEPROMchar;
1551:stk500boot.c  **** int		errorCount;
1552:stk500boot.c  **** 
1553:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
1554:stk500boot.c  **** 	PrintNewLine();
1555:stk500boot.c  **** 	ii			=	0;
1556:stk500boot.c  **** #if (FLASHEND > 0x10000)
1557:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1558:stk500boot.c  **** #else
1559:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1560:stk500boot.c  **** #endif
1561:stk500boot.c  **** 	{
1562:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
1563:stk500boot.c  **** 		if (theChar == 0)
1564:stk500boot.c  **** 		{
1565:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1566:stk500boot.c  **** 		}
1567:stk500boot.c  **** 		else
1568:stk500boot.c  **** 		{
1569:stk500boot.c  **** 			sendchar(theChar);
1570:stk500boot.c  **** 		}
1571:stk500boot.c  **** 		ii++;
1572:stk500boot.c  **** 	}
1573:stk500boot.c  **** 
1574:stk500boot.c  **** 	//*	no go back through and test
1575:stk500boot.c  **** 	PrintNewLine();
1576:stk500boot.c  **** 	PrintNewLine();
1577:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
1578:stk500boot.c  **** 	PrintNewLine();
1579:stk500boot.c  **** 	errorCount	=	0;
1580:stk500boot.c  **** 	ii			=	0;
1581:stk500boot.c  **** #if (FLASHEND > 0x10000)
1582:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1583:stk500boot.c  **** #else
1584:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1585:stk500boot.c  **** #endif
1586:stk500boot.c  **** 	{
1587:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
1588:stk500boot.c  **** 		if (theEEPROMchar == 0)
1589:stk500boot.c  **** 		{
1590:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1591:stk500boot.c  **** 		}
1592:stk500boot.c  **** 		else
1593:stk500boot.c  **** 		{
1594:stk500boot.c  **** 			sendchar(theEEPROMchar);
1595:stk500boot.c  **** 		}
1596:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1597:stk500boot.c  **** 		{
1598:stk500boot.c  **** 			errorCount++;
1599:stk500boot.c  **** 		}
1600:stk500boot.c  **** 		ii++;
1601:stk500boot.c  **** 	}
1602:stk500boot.c  **** 	PrintNewLine();
1603:stk500boot.c  **** 	PrintNewLine();
1604:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
1605:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1606:stk500boot.c  **** 	PrintNewLine();
1607:stk500boot.c  **** 	PrintNewLine();
1608:stk500boot.c  **** 
1609:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1610:stk500boot.c  **** 
1611:stk500boot.c  **** }
1612:stk500boot.c  **** 
1613:stk500boot.c  **** 
1614:stk500boot.c  **** 
1615:stk500boot.c  **** #if (FLASHEND > 0x08000)
1616:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough 
1617:stk500boot.c  **** //*	memory to include this
1618:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1619:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1620:stk500boot.c  **** //		#warning Interrupt vectors not defined
1621:stk500boot.c  **** //	#endif
1622:stk500boot.c  **** #endif
1623:stk500boot.c  **** 
1624:stk500boot.c  **** //************************************************************************
1625:stk500boot.c  **** static void	VectorDisplay(void)
1626:stk500boot.c  **** {
1627:stk500boot.c  **** unsigned long	byte1;
1628:stk500boot.c  **** unsigned long	byte2;
1629:stk500boot.c  **** unsigned long	byte3;
1630:stk500boot.c  **** unsigned long	byte4;
1631:stk500boot.c  **** unsigned long	word1;
1632:stk500boot.c  **** unsigned long	word2;
1633:stk500boot.c  **** int				vectorIndex;
1634:stk500boot.c  **** unsigned long	myMemoryPtr;
1635:stk500boot.c  **** unsigned long	wordMemoryAddress;
1636:stk500boot.c  **** unsigned long	realitiveAddr;
1637:stk500boot.c  **** unsigned long	myFullAddress;
1638:stk500boot.c  **** unsigned long	absoluteAddr;
1639:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1640:stk500boot.c  **** 	long		stringPointer;
1641:stk500boot.c  **** #endif
1642:stk500boot.c  **** 
1643:stk500boot.c  **** 	myMemoryPtr		=	0;
1644:stk500boot.c  **** 	vectorIndex		=	0;
1645:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1646:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
1647:stk500boot.c  **** 	//					 V#   ADDR   op code
1648:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1649:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1650:stk500boot.c  **** 	{
1651:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1652:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1653:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1654:stk500boot.c  **** 		sendchar(0x20);
1655:stk500boot.c  **** 		sendchar('-');
1656:stk500boot.c  **** 		sendchar(0x20);
1657:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1658:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1659:stk500boot.c  **** 		sendchar(0x20);
1660:stk500boot.c  **** 		sendchar('=');
1661:stk500boot.c  **** 		sendchar(0x20);
1662:stk500boot.c  **** 
1663:stk500boot.c  **** 	
1664:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1665:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1666:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1667:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1668:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1669:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1670:stk500boot.c  **** 	#else
1671:stk500boot.c  **** 		byte1	=	pgm_read_byte_near(myMemoryPtr++);
1672:stk500boot.c  **** 		byte2	=	pgm_read_byte_near(myMemoryPtr++);
1673:stk500boot.c  **** 		byte3	=	pgm_read_byte_near(myMemoryPtr++);
1674:stk500boot.c  **** 		byte4	=	pgm_read_byte_near(myMemoryPtr++);
1675:stk500boot.c  **** 	#endif
1676:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1677:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1678:stk500boot.c  **** 
1679:stk500boot.c  **** 
1680:stk500boot.c  **** 		PrintHexByte(byte2);
1681:stk500boot.c  **** 		sendchar(0x20);
1682:stk500boot.c  **** 		PrintHexByte(byte1);
1683:stk500boot.c  **** 		sendchar(0x20);
1684:stk500boot.c  **** 		PrintHexByte(byte4);
1685:stk500boot.c  **** 		sendchar(0x20);
1686:stk500boot.c  **** 		PrintHexByte(byte3);
1687:stk500boot.c  **** 		sendchar(0x20);
1688:stk500boot.c  **** 	
1689:stk500boot.c  **** 		if (word1 == 0xffff)
1690:stk500boot.c  **** 		{
1691:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
1692:stk500boot.c  **** 		}
1693:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1694:stk500boot.c  **** 		{
1695:stk500boot.c  **** 			//*	rjmp instruction
1696:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
1697:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
1698:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1699:stk500boot.c  **** 
1700:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
1701:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
1702:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
1703:stk500boot.c  **** 			sendchar(0x20);
1704:stk500boot.c  **** 			sendchar('>');
1705:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1706:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1707:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1708:stk500boot.c  **** 	
1709:stk500boot.c  **** 		}
1710:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1711:stk500boot.c  **** 		{
1712:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1713:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1714:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1715:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1716:stk500boot.c  **** 								word2;
1717:stk500boot.c  **** 							
1718:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1719:stk500boot.c  **** 							
1720:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
1721:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1722:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1723:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1724:stk500boot.c  **** 			sendchar(0x20);
1725:stk500boot.c  **** 			sendchar('>');
1726:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1727:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1728:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1729:stk500boot.c  **** 		}
1730:stk500boot.c  **** 
1731:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1732:stk500boot.c  **** 		sendchar(0x20);
1733:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1734:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1735:stk500boot.c  **** 	#else
1736:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1737:stk500boot.c  **** 	#endif
1738:stk500boot.c  **** 		PrintFromPROGMEM((char *)stringPointer, 0);
1739:stk500boot.c  **** 	#endif
1740:stk500boot.c  **** 		PrintNewLine();
1741:stk500boot.c  **** 
1742:stk500boot.c  **** 		vectorIndex++;
1743:stk500boot.c  **** 	}
1744:stk500boot.c  **** }
1745:stk500boot.c  **** 
1746:stk500boot.c  **** //************************************************************************
1747:stk500boot.c  **** static void	PrintAvailablePort(char thePortLetter)
1748:stk500boot.c  **** {
 249               		.loc 1 1748 0
 250               		.cfi_startproc
 251               	.LVL17:
 252 000e CF93      		push r28
 253               	.LCFI2:
 254               		.cfi_def_cfa_offset 4
 255               		.cfi_offset 28, -3
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 1 */
 259               	.L__stack_usage = 1
 260 0010 C82F      		mov r28,r24
1749:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_PORT, 0);
 261               		.loc 1 1749 0
 262 0012 60E0      		ldi r22,0
 263 0014 80E0      		ldi r24,lo8(gTextMsg_PORT)
 264 0016 90E0      		ldi r25,hi8(gTextMsg_PORT)
 265               	.LVL18:
 266 0018 0E94 0000 		call PrintFromPROGMEM
 267               	.LVL19:
1750:stk500boot.c  **** 	sendchar(thePortLetter);
 268               		.loc 1 1750 0
 269 001c 8C2F      		mov r24,r28
 270 001e 0E94 0000 		call sendchar
 271               	.LVL20:
 272               	/* epilogue start */
1751:stk500boot.c  **** 	PrintNewLine();
1752:stk500boot.c  **** }
 273               		.loc 1 1752 0
 274 0022 CF91      		pop r28
 275               	.LVL21:
1751:stk500boot.c  **** 	PrintNewLine();
 276               		.loc 1 1751 0
 277 0024 0C94 0000 		jmp PrintNewLine
 278               	.LVL22:
 279               		.cfi_endproc
 280               	.LFE29:
 282               		.text
 283               	.global	PrintFromPROGMEMln
 285               	PrintFromPROGMEMln:
 286               	.LFB20:
1318:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 287               		.loc 1 1318 0
 288               		.cfi_startproc
 289               	.LVL23:
 290               	/* prologue: function */
 291               	/* frame size = 0 */
 292               	/* stack size = 0 */
 293               	.L__stack_usage = 0
1319:stk500boot.c  **** 
 294               		.loc 1 1319 0
 295 006a 0E94 0000 		call PrintFromPROGMEM
 296               	.LVL24:
1321:stk500boot.c  **** }
 297               		.loc 1 1321 0
 298 006e 0C94 0000 		jmp PrintNewLine
 299               	.LVL25:
 300               		.cfi_endproc
 301               	.LFE20:
 303               	.global	PrintString
 305               	PrintString:
 306               	.LFB21:
1327:stk500boot.c  **** char	theChar;
 307               		.loc 1 1327 0
 308               		.cfi_startproc
 309               	.LVL26:
 310 0072 CF93      		push r28
 311               	.LCFI3:
 312               		.cfi_def_cfa_offset 4
 313               		.cfi_offset 28, -3
 314 0074 DF93      		push r29
 315               	.LCFI4:
 316               		.cfi_def_cfa_offset 5
 317               		.cfi_offset 29, -4
 318               	/* prologue: function */
 319               	/* frame size = 0 */
 320               	/* stack size = 2 */
 321               	.L__stack_usage = 2
 322 0076 EC01      		movw r28,r24
 323               	.LVL27:
 324               	.L20:
1335:stk500boot.c  **** 		if (theChar != 0)
 325               		.loc 1 1335 0
 326 0078 8991      		ld r24,Y+
 327               	.LVL28:
1336:stk500boot.c  **** 		{
 328               		.loc 1 1336 0
 329 007a 8823      		tst r24
 330 007c 01F0      		breq .L18
1338:stk500boot.c  **** 		}
 331               		.loc 1 1338 0
 332 007e 0E94 0000 		call sendchar
 333               	.LVL29:
 334 0082 00C0      		rjmp .L20
 335               	.LVL30:
 336               	.L18:
 337               	/* epilogue start */
1342:stk500boot.c  **** 
 338               		.loc 1 1342 0
 339 0084 DF91      		pop r29
 340 0086 CF91      		pop r28
 341               	.LVL31:
 342 0088 0895      		ret
 343               		.cfi_endproc
 344               	.LFE21:
 346               	.global	PrintHexByte
 348               	PrintHexByte:
 349               	.LFB22:
1346:stk500boot.c  **** char	theChar;
 350               		.loc 1 1346 0
 351               		.cfi_startproc
 352               	.LVL32:
 353 008a CF93      		push r28
 354               	.LCFI5:
 355               		.cfi_def_cfa_offset 4
 356               		.cfi_offset 28, -3
 357               	/* prologue: function */
 358               	/* frame size = 0 */
 359               	/* stack size = 1 */
 360               	.L__stack_usage = 1
 361 008c C82F      		mov r28,r24
1349:stk500boot.c  **** 	if (theChar > 0x39)
 362               		.loc 1 1349 0
 363 008e 982F      		mov r25,r24
 364 0090 9295      		swap r25
 365 0092 9F70      		andi r25,lo8(15)
 366 0094 80E3      		ldi r24,lo8(48)
 367               	.LVL33:
 368 0096 890F      		add r24,r25
 369               	.LVL34:
1350:stk500boot.c  **** 	{
 370               		.loc 1 1350 0
 371 0098 8A33      		cpi r24,lo8(58)
 372 009a 00F0      		brlo .L22
1352:stk500boot.c  **** 	}
 373               		.loc 1 1352 0
 374 009c 87E3      		ldi r24,lo8(55)
 375               	.LVL35:
 376 009e 890F      		add r24,r25
 377               	.LVL36:
 378               	.L22:
1354:stk500boot.c  **** 
 379               		.loc 1 1354 0
 380 00a0 0E94 0000 		call sendchar
 381               	.LVL37:
1356:stk500boot.c  **** 	if (theChar > 0x39)
 382               		.loc 1 1356 0
 383 00a4 CF70      		andi r28,lo8(15)
 384               	.LVL38:
 385 00a6 80E3      		ldi r24,lo8(48)
 386 00a8 8C0F      		add r24,r28
 387               	.LVL39:
1357:stk500boot.c  **** 	{
 388               		.loc 1 1357 0
 389 00aa 8A33      		cpi r24,lo8(58)
 390 00ac 00F0      		brlo .L23
1359:stk500boot.c  **** 	}
 391               		.loc 1 1359 0
 392 00ae 87E3      		ldi r24,lo8(55)
 393               	.LVL40:
 394 00b0 8C0F      		add r24,r28
 395               	.LVL41:
 396               	.L23:
 397               	/* epilogue start */
1362:stk500boot.c  **** 
 398               		.loc 1 1362 0
 399 00b2 CF91      		pop r28
1361:stk500boot.c  **** }
 400               		.loc 1 1361 0
 401 00b4 0C94 0000 		jmp sendchar
 402               	.LVL42:
 403               		.cfi_endproc
 404               	.LFE22:
 406               		.section	.text.unlikely
 408               	DumpHex.constprop.0:
 409               	.LFB34:
1475:stk500boot.c  **** {
 410               		.loc 1 1475 0
 411               		.cfi_startproc
 412               	.LVL43:
 413 0028 2F92      		push r2
 414               	.LCFI6:
 415               		.cfi_def_cfa_offset 4
 416               		.cfi_offset 2, -3
 417 002a 3F92      		push r3
 418               	.LCFI7:
 419               		.cfi_def_cfa_offset 5
 420               		.cfi_offset 3, -4
 421 002c 4F92      		push r4
 422               	.LCFI8:
 423               		.cfi_def_cfa_offset 6
 424               		.cfi_offset 4, -5
 425 002e 5F92      		push r5
 426               	.LCFI9:
 427               		.cfi_def_cfa_offset 7
 428               		.cfi_offset 5, -6
 429 0030 6F92      		push r6
 430               	.LCFI10:
 431               		.cfi_def_cfa_offset 8
 432               		.cfi_offset 6, -7
 433 0032 7F92      		push r7
 434               	.LCFI11:
 435               		.cfi_def_cfa_offset 9
 436               		.cfi_offset 7, -8
 437 0034 8F92      		push r8
 438               	.LCFI12:
 439               		.cfi_def_cfa_offset 10
 440               		.cfi_offset 8, -9
 441 0036 9F92      		push r9
 442               	.LCFI13:
 443               		.cfi_def_cfa_offset 11
 444               		.cfi_offset 9, -10
 445 0038 AF92      		push r10
 446               	.LCFI14:
 447               		.cfi_def_cfa_offset 12
 448               		.cfi_offset 10, -11
 449 003a BF92      		push r11
 450               	.LCFI15:
 451               		.cfi_def_cfa_offset 13
 452               		.cfi_offset 11, -12
 453 003c CF92      		push r12
 454               	.LCFI16:
 455               		.cfi_def_cfa_offset 14
 456               		.cfi_offset 12, -13
 457 003e DF92      		push r13
 458               	.LCFI17:
 459               		.cfi_def_cfa_offset 15
 460               		.cfi_offset 13, -14
 461 0040 EF92      		push r14
 462               	.LCFI18:
 463               		.cfi_def_cfa_offset 16
 464               		.cfi_offset 14, -15
 465 0042 FF92      		push r15
 466               	.LCFI19:
 467               		.cfi_def_cfa_offset 17
 468               		.cfi_offset 15, -16
 469 0044 0F93      		push r16
 470               	.LCFI20:
 471               		.cfi_def_cfa_offset 18
 472               		.cfi_offset 16, -17
 473 0046 1F93      		push r17
 474               	.LCFI21:
 475               		.cfi_def_cfa_offset 19
 476               		.cfi_offset 17, -18
 477 0048 CF93      		push r28
 478               	.LCFI22:
 479               		.cfi_def_cfa_offset 20
 480               		.cfi_offset 28, -19
 481 004a DF93      		push r29
 482               	.LCFI23:
 483               		.cfi_def_cfa_offset 21
 484               		.cfi_offset 29, -20
 485 004c CDB7      		in r28,__SP_L__
 486 004e DEB7      		in r29,__SP_H__
 487               	.LCFI24:
 488               		.cfi_def_cfa_register 28
 489 0050 6397      		sbiw r28,19
 490               	.LCFI25:
 491               		.cfi_def_cfa_offset 40
 492 0052 0FB6      		in __tmp_reg__,__SREG__
 493 0054 F894      		cli
 494 0056 DEBF      		out __SP_H__,r29
 495 0058 0FBE      		out __SREG__,__tmp_reg__
 496 005a CDBF      		out __SP_L__,r28
 497               	/* prologue: function */
 498               	/* frame size = 19 */
 499               	/* stack size = 37 */
 500               	.L__stack_usage = 37
 501 005c 8B8B      		std Y+19,r24
 502 005e 6A01      		movw r12,r20
 503 0060 7B01      		movw r14,r22
 504               	.LVL44:
1475:stk500boot.c  **** {
 505               		.loc 1 1475 0
 506 0062 80E1      		ldi r24,lo8(16)
 507 0064 A82E      		mov r10,r24
 508               	.LVL45:
 509 0066 4E01      		movw r8,r28
 510 0068 81E1      		ldi r24,17
 511 006a 880E      		add r8,r24
 512 006c 911C      		adc r9,__zero_reg__
 513               	.LVL46:
 514               	.L33:
1489:stk500boot.c  **** 		{
 515               		.loc 1 1489 0
 516 006e E1E0      		ldi r30,1
 517 0070 CE16      		cp r12,r30
 518 0072 D104      		cpc r13,__zero_reg__
 519 0074 EE06      		cpc r14,r30
 520 0076 F104      		cpc r15,__zero_reg__
 521 0078 00F0      		brlo .L25
1491:stk500boot.c  **** 		}
 522               		.loc 1 1491 0
 523 007a 8E2D      		mov r24,r14
 524 007c 0E94 0000 		call PrintHexByte
 525               	.LVL47:
 526               	.L25:
1493:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 527               		.loc 1 1493 0
 528 0080 8D2D      		mov r24,r13
 529 0082 0E94 0000 		call PrintHexByte
 530               	.LVL48:
1494:stk500boot.c  **** 		sendchar(0x20);
 531               		.loc 1 1494 0
 532 0086 8C2D      		mov r24,r12
 533 0088 0E94 0000 		call PrintHexByte
 534               	.LVL49:
1495:stk500boot.c  **** 		sendchar('-');
 535               		.loc 1 1495 0
 536 008c 80E2      		ldi r24,lo8(32)
 537 008e 0E94 0000 		call sendchar
 538               	.LVL50:
1496:stk500boot.c  **** 		sendchar(0x20);
 539               		.loc 1 1496 0
 540 0092 8DE2      		ldi r24,lo8(45)
 541 0094 0E94 0000 		call sendchar
 542               	.LVL51:
1497:stk500boot.c  **** 
 543               		.loc 1 1497 0
 544 0098 80E2      		ldi r24,lo8(32)
 545 009a 0E94 0000 		call sendchar
 546               	.LVL52:
1499:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
 547               		.loc 1 1499 0
 548 009e 1982      		std Y+1,__zero_reg__
 549               	.LVL53:
 550 00a0 8E01      		movw r16,r28
 551 00a2 0F5F      		subi r16,-1
 552 00a4 1F4F      		sbci r17,-1
 553 00a6 2601      		movw r4,r12
 554 00a8 3701      		movw r6,r14
 555 00aa 1801      		movw r2,r16
 556               	.LVL54:
 557               	.L32:
1502:stk500boot.c  **** 			{
 558               		.loc 1 1502 0
 559 00ac FB89      		ldd r31,Y+19
 560 00ae F130      		cpi r31,lo8(1)
 561 00b0 01F4      		brne .+2
 562 00b2 00C0      		rjmp .L27
 563 00b4 F230      		cpi r31,lo8(2)
 564 00b6 01F4      		brne .+2
 565 00b8 00C0      		rjmp .L28
 566               	.LVL55:
 567               	.LBB81:
1506:stk500boot.c  **** 				#else
 568               		.loc 1 1506 0
 569               	/* #APP */
 570               	 ;  1506 "stk500boot.c" 1
 571 00ba 6BBE      		out 59, r6
 572 00bc F201      		movw r30, r4
 573 00be B790      		elpm r11, Z+
 574               		
 575               	 ;  0 "" 2
 576               	.LVL56:
 577               	/* #NOAPP */
 578               	.L29:
 579               	.LBE81:
1521:stk500boot.c  **** 			sendchar(0x20);
 580               		.loc 1 1521 0
 581 00c0 8B2D      		mov r24,r11
 582 00c2 0E94 0000 		call PrintHexByte
 583               	.LVL57:
1522:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 584               		.loc 1 1522 0
 585 00c6 80E2      		ldi r24,lo8(32)
 586 00c8 0E94 0000 		call sendchar
 587               	.LVL58:
1523:stk500boot.c  **** 			{
 588               		.loc 1 1523 0
 589 00cc 80EE      		ldi r24,lo8(-32)
 590 00ce 8B0D      		add r24,r11
 591 00d0 8F35      		cpi r24,lo8(95)
 592 00d2 00F4      		brsh .L30
1525:stk500boot.c  **** 			}
 593               		.loc 1 1525 0
 594 00d4 F801      		movw r30,r16
 595 00d6 B082      		st Z,r11
 596               	.L31:
1532:stk500boot.c  **** 		}
 597               		.loc 1 1532 0
 598 00d8 EFEF      		ldi r30,-1
 599 00da 4E1A      		sub r4,r30
 600 00dc 5E0A      		sbc r5,r30
 601 00de 6E0A      		sbc r6,r30
 602 00e0 7E0A      		sbc r7,r30
 603               	.LVL59:
 604 00e2 0F5F      		subi r16,-1
 605 00e4 1F4F      		sbci r17,-1
1500:stk500boot.c  **** 		{
 606               		.loc 1 1500 0
 607 00e6 0815      		cp r16,r8
 608 00e8 1905      		cpc r17,r9
 609 00ea 01F4      		brne .L32
 610 00ec F0E1      		ldi r31,16
 611 00ee CF0E      		add r12,r31
 612 00f0 D11C      		adc r13,__zero_reg__
 613 00f2 E11C      		adc r14,__zero_reg__
 614 00f4 F11C      		adc r15,__zero_reg__
1534:stk500boot.c  **** 		PrintString(asciiDump);
 615               		.loc 1 1534 0
 616 00f6 198A      		std Y+17,__zero_reg__
1535:stk500boot.c  **** 		PrintNewLine();
 617               		.loc 1 1535 0
 618 00f8 C101      		movw r24,r2
 619 00fa 0E94 0000 		call PrintString
 620               	.LVL60:
1536:stk500boot.c  **** 
 621               		.loc 1 1536 0
 622 00fe 0E94 0000 		call PrintNewLine
 623               	.LVL61:
 624 0102 AA94      		dec r10
 625               	.LVL62:
1487:stk500boot.c  **** 	{
 626               		.loc 1 1487 0
 627 0104 A110      		cpse r10,__zero_reg__
 628 0106 00C0      		rjmp .L33
 629               	/* epilogue start */
1540:stk500boot.c  **** 
 630               		.loc 1 1540 0
 631 0108 6396      		adiw r28,19
 632               	.LVL63:
 633 010a 0FB6      		in __tmp_reg__,__SREG__
 634 010c F894      		cli
 635 010e DEBF      		out __SP_H__,r29
 636 0110 0FBE      		out __SREG__,__tmp_reg__
 637 0112 CDBF      		out __SP_L__,r28
 638 0114 DF91      		pop r29
 639 0116 CF91      		pop r28
 640               	.LVL64:
 641 0118 1F91      		pop r17
 642 011a 0F91      		pop r16
 643 011c FF90      		pop r15
 644 011e EF90      		pop r14
 645 0120 DF90      		pop r13
 646 0122 CF90      		pop r12
 647               	.LVL65:
 648 0124 BF90      		pop r11
 649 0126 AF90      		pop r10
 650               	.LVL66:
 651 0128 9F90      		pop r9
 652 012a 8F90      		pop r8
 653 012c 7F90      		pop r7
 654 012e 6F90      		pop r6
 655 0130 5F90      		pop r5
 656 0132 4F90      		pop r4
 657 0134 3F90      		pop r3
 658 0136 2F90      		pop r2
 659 0138 0895      		ret
 660               	.LVL67:
 661               	.L27:
1513:stk500boot.c  **** 					break;
 662               		.loc 1 1513 0
 663 013a C201      		movw r24,r4
 664 013c 0E94 0000 		call eeprom_read_byte
 665               	.LVL68:
 666 0140 B82E      		mov r11,r24
 667               	.LVL69:
 668 0142 00C0      		rjmp .L29
 669               	.LVL70:
 670               	.L28:
1517:stk500boot.c  **** 					break;
 671               		.loc 1 1517 0
 672 0144 F201      		movw r30,r4
 673 0146 B080      		ld r11,Z
 674               	.LVL71:
 675 0148 00C0      		rjmp .L29
 676               	.L30:
1529:stk500boot.c  **** 			}
 677               		.loc 1 1529 0
 678 014a 8EE2      		ldi r24,lo8(46)
 679 014c F801      		movw r30,r16
 680 014e 8083      		st Z,r24
 681 0150 00C0      		rjmp .L31
 682               		.cfi_endproc
 683               	.LFE34:
 685               		.text
 686               	.global	PrintDecInt
 688               	PrintDecInt:
 689               	.LFB23:
1366:stk500boot.c  **** int	theChar;
 690               		.loc 1 1366 0
 691               		.cfi_startproc
 692               	.LVL72:
 693 00b8 0F93      		push r16
 694               	.LCFI26:
 695               		.cfi_def_cfa_offset 4
 696               		.cfi_offset 16, -3
 697 00ba 1F93      		push r17
 698               	.LCFI27:
 699               		.cfi_def_cfa_offset 5
 700               		.cfi_offset 17, -4
 701 00bc CF93      		push r28
 702               	.LCFI28:
 703               		.cfi_def_cfa_offset 6
 704               		.cfi_offset 28, -5
 705 00be DF93      		push r29
 706               	.LCFI29:
 707               		.cfi_def_cfa_offset 7
 708               		.cfi_offset 29, -6
 709               	/* prologue: function */
 710               	/* frame size = 0 */
 711               	/* stack size = 4 */
 712               	.L__stack_usage = 4
 713 00c0 EC01      		movw r28,r24
 714 00c2 8B01      		movw r16,r22
 715               	.LVL73:
1372:stk500boot.c  **** 	{
 716               		.loc 1 1372 0
 717 00c4 8536      		cpi r24,101
 718 00c6 9105      		cpc r25,__zero_reg__
 719 00c8 04F4      		brge .L37
1372:stk500boot.c  **** 	{
 720               		.loc 1 1372 0 is_stmt 0 discriminator 1
 721 00ca 6330      		cpi r22,3
 722 00cc 7105      		cpc r23,__zero_reg__
 723 00ce 04F0      		brlt .L38
 724               	.L37:
 725               	.LVL74:
1374:stk500boot.c  **** 		sendchar(theChar );
 726               		.loc 1 1374 0 is_stmt 1
 727 00d0 CE01      		movw r24,r28
 728               	.LVL75:
 729 00d2 64E6      		ldi r22,lo8(100)
 730 00d4 70E0      		ldi r23,0
 731               	.LVL76:
 732 00d6 0E94 0000 		call __divmodhi4
 733               	.LVL77:
1375:stk500boot.c  **** 	}
 734               		.loc 1 1375 0
 735 00da 80E3      		ldi r24,lo8(48)
 736 00dc 860F      		add r24,r22
 737 00de 0E94 0000 		call sendchar
 738               	.LVL78:
 739               	.L38:
1378:stk500boot.c  **** 	{
 740               		.loc 1 1378 0
 741 00e2 CB30      		cpi r28,11
 742 00e4 D105      		cpc r29,__zero_reg__
 743 00e6 04F4      		brge .L39
1378:stk500boot.c  **** 	{
 744               		.loc 1 1378 0 is_stmt 0 discriminator 1
 745 00e8 0230      		cpi r16,2
 746 00ea 1105      		cpc r17,__zero_reg__
 747 00ec 04F0      		brlt .L40
 748               	.L39:
 749               	.LVL79:
1380:stk500boot.c  **** 		sendchar(theChar );
 750               		.loc 1 1380 0 is_stmt 1
 751 00ee CE01      		movw r24,r28
 752 00f0 64E6      		ldi r22,lo8(100)
 753 00f2 70E0      		ldi r23,0
 754 00f4 0E94 0000 		call __divmodhi4
 755 00f8 6AE0      		ldi r22,lo8(10)
 756 00fa 70E0      		ldi r23,0
 757 00fc 0E94 0000 		call __divmodhi4
1381:stk500boot.c  **** 	}
 758               		.loc 1 1381 0
 759 0100 80E3      		ldi r24,lo8(48)
 760 0102 860F      		add r24,r22
 761 0104 0E94 0000 		call sendchar
 762               	.LVL80:
 763               	.L40:
1383:stk500boot.c  **** 	sendchar(theChar );
 764               		.loc 1 1383 0
 765 0108 CE01      		movw r24,r28
 766 010a 6AE0      		ldi r22,lo8(10)
 767 010c 70E0      		ldi r23,0
 768 010e 0E94 0000 		call __divmodhi4
1384:stk500boot.c  **** }
 769               		.loc 1 1384 0
 770 0112 805D      		subi r24,lo8(-(48))
 771               	/* epilogue start */
1385:stk500boot.c  **** 
 772               		.loc 1 1385 0
 773 0114 DF91      		pop r29
 774 0116 CF91      		pop r28
 775               	.LVL81:
 776 0118 1F91      		pop r17
 777 011a 0F91      		pop r16
 778               	.LVL82:
1384:stk500boot.c  **** }
 779               		.loc 1 1384 0
 780 011c 0C94 0000 		jmp sendchar
 781               	.LVL83:
 782               		.cfi_endproc
 783               	.LFE23:
 785               		.section	.text.startup,"ax",@progbits
 786               	.global	main
 788               	main:
 789               	.LFB17:
 532:stk500boot.c  **** 	address_t		address			=	0;
 790               		.loc 1 532 0
 791               		.cfi_startproc
 792 0000 CF93      		push r28
 793               	.LCFI30:
 794               		.cfi_def_cfa_offset 4
 795               		.cfi_offset 28, -3
 796 0002 DF93      		push r29
 797               	.LCFI31:
 798               		.cfi_def_cfa_offset 5
 799               		.cfi_offset 29, -4
 800 0004 CDB7      		in r28,__SP_L__
 801 0006 DEB7      		in r29,__SP_H__
 802               	.LCFI32:
 803               		.cfi_def_cfa_register 28
 804 0008 C653      		subi r28,54
 805 000a D140      		sbci r29,1
 806               	.LCFI33:
 807               		.cfi_def_cfa_offset 315
 808 000c 0FB6      		in __tmp_reg__,__SREG__
 809 000e F894      		cli
 810 0010 DEBF      		out __SP_H__,r29
 811 0012 0FBE      		out __SREG__,__tmp_reg__
 812 0014 CDBF      		out __SP_L__,r28
 813               	/* prologue: function */
 814               	/* frame size = 310 */
 815               	/* stack size = 312 */
 816               	.L__stack_usage = 312
 817               	.LVL84:
 553:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 818               		.loc 1 553 0
 819               	/* #APP */
 820               	 ;  553 "stk500boot.c" 1
 821               		.set __stack, 8703
 822               	 ;  0 "" 2
 554:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 823               		.loc 1 554 0
 824               	 ;  554 "stk500boot.c" 1
 825 0016 01E2      		ldi	16, 33
 826               	 ;  0 "" 2
 555:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 827               		.loc 1 555 0
 828               	 ;  555 "stk500boot.c" 1
 829 0018 0EBF      		out 62,16
 830               	 ;  0 "" 2
 556:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 831               		.loc 1 556 0
 832               	 ;  556 "stk500boot.c" 1
 833 001a 0FEF      		ldi	16, 255
 834               	 ;  0 "" 2
 557:stk500boot.c  **** 
 835               		.loc 1 557 0
 836               	 ;  557 "stk500boot.c" 1
 837 001c 0DBF      		out 61,16
 838               	 ;  0 "" 2
 564:stk500boot.c  **** 
 839               		.loc 1 564 0
 840               	/* #NOAPP */
 841 001e 94B7      		in r25,0x34
 842               	.LVL85:
 566:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 843               		.loc 1 566 0
 844               	/* #APP */
 845               	 ;  566 "stk500boot.c" 1
 846 0020 F894      		cli
 847               	 ;  0 "" 2
 567:stk500boot.c  **** 	MCUSR	=	0;
 848               		.loc 1 567 0
 849               	 ;  567 "stk500boot.c" 1
 850 0022 A895      		wdr
 851               	 ;  0 "" 2
 568:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 852               		.loc 1 568 0
 853               	/* #NOAPP */
 854 0024 14BE      		out 0x34,__zero_reg__
 569:stk500boot.c  **** 	WDTCSR	=	0;
 855               		.loc 1 569 0
 856 0026 8091 6000 		lds r24,96
 857 002a 8861      		ori r24,lo8(24)
 858 002c 8093 6000 		sts 96,r24
 570:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 859               		.loc 1 570 0
 860 0030 1092 6000 		sts 96,__zero_reg__
 571:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 861               		.loc 1 571 0
 862               	/* #APP */
 863               	 ;  571 "stk500boot.c" 1
 864 0034 7894      		sei
 865               	 ;  0 "" 2
 573:stk500boot.c  **** 	{
 866               		.loc 1 573 0
 867               	/* #NOAPP */
 868 0036 93FF      		sbrs r25,3
 869 0038 00C0      		rjmp .L42
 575:stk500boot.c  **** 	}
 870               		.loc 1 575 0
 871 003a E091 0000 		lds r30,app_start
 872 003e F091 0000 		lds r31,app_start+1
 873 0042 1995      		eicall
 874               	.LVL86:
 875               	.L42:
 597:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 876               		.loc 1 597 0
 877 0044 279A      		sbi 0x4,7
 599:stk500boot.c  **** 
 878               		.loc 1 599 0
 879 0046 2F9A      		sbi 0x5,7
 617:stk500boot.c  **** #endif
 880               		.loc 1 617 0
 881 0048 8091 C800 		lds r24,200
 882 004c 8260      		ori r24,lo8(2)
 883 004e 8093 C800 		sts 200,r24
 619:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 884               		.loc 1 619 0
 885 0052 80E1      		ldi r24,lo8(16)
 886 0054 8093 CC00 		sts 204,r24
 620:stk500boot.c  **** 
 887               		.loc 1 620 0
 888 0058 88E1      		ldi r24,lo8(24)
 889 005a 8093 C900 		sts 201,r24
 622:stk500boot.c  **** 
 890               		.loc 1 622 0
 891               	/* #APP */
 892               	 ;  622 "stk500boot.c" 1
 893 005e 0000      		nop
 894               	 ;  0 "" 2
 895               	/* #NOAPP */
 896 0060 10E0      		ldi r17,0
 897 0062 00E0      		ldi r16,0
 581:stk500boot.c  **** 	boot_state	=	0;
 898               		.loc 1 581 0
 899 0064 C12C      		mov r12,__zero_reg__
 900 0066 D12C      		mov r13,__zero_reg__
 901 0068 7601      		movw r14,r12
 652:stk500boot.c  **** 			{
 902               		.loc 1 652 0
 903 006a F7EC      		ldi r31,lo8(-57)
 904 006c 8F2E      		mov r8,r31
 905 006e FBE1      		ldi r31,lo8(27)
 906 0070 9F2E      		mov r9,r31
 907 0072 A12C      		mov r10,__zero_reg__
 908 0074 B12C      		mov r11,__zero_reg__
 909               	.LVL87:
 910               	.L43:
 911               	.LBB160:
 912               	.LBB161:
 477:stk500boot.c  **** }
 913               		.loc 1 477 0
 914 0076 8091 C800 		lds r24,200
 915               	.LBE161:
 916               	.LBE160:
 643:stk500boot.c  **** 		{
 917               		.loc 1 643 0
 918 007a 87FD      		sbrc r24,7
 919 007c 00C0      		rjmp .L46
 643:stk500boot.c  **** 		{
 920               		.loc 1 643 0 is_stmt 0 discriminator 1
 921 007e 0115      		cp r16,__zero_reg__
 922 0080 1105      		cpc r17,__zero_reg__
 923 0082 01F0      		breq .L47
 924               	.L46:
 925               	.LVL88:
 663:stk500boot.c  **** 	{
 926               		.loc 1 663 0 is_stmt 1
 927 0084 012B      		or r16,r17
 928 0086 01F0      		breq .+2
 929 0088 00C0      		rjmp .L49
 549:stk500boot.c  **** #endif
 930               		.loc 1 549 0
 931 008a C55D      		subi r28,lo8(-299)
 932 008c DE4F      		sbci r29,hi8(-299)
 933 008e 1982      		std Y+1,__zero_reg__
 934 0090 1882      		st Y,__zero_reg__
 935 0092 CB52      		subi r28,lo8(299)
 936 0094 D140      		sbci r29,hi8(299)
 548:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 937               		.loc 1 548 0
 938 0096 F12C      		mov r15,__zero_reg__
 939 0098 E12C      		mov r14,__zero_reg__
 536:stk500boot.c  **** 	unsigned char	checksum		=	0;
 940               		.loc 1 536 0
 941 009a CE5D      		subi r28,lo8(-290)
 942 009c DE4F      		sbci r29,hi8(-290)
 943 009e 1982      		std Y+1,__zero_reg__
 944 00a0 1882      		st Y,__zero_reg__
 945 00a2 C252      		subi r28,lo8(290)
 946 00a4 D140      		sbci r29,hi8(290)
 534:stk500boot.c  **** 	unsigned char	msgParseState;
 947               		.loc 1 534 0
 948 00a6 CC5D      		subi r28,lo8(-292)
 949 00a8 DE4F      		sbci r29,hi8(-292)
 950 00aa 1882      		st Y,__zero_reg__
 951 00ac 1982      		std Y+1,__zero_reg__
 952 00ae 1A82      		std Y+2,__zero_reg__
 953 00b0 1B82      		std Y+3,__zero_reg__
 954 00b2 C452      		subi r28,lo8(292)
 955 00b4 D140      		sbci r29,hi8(292)
 533:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 956               		.loc 1 533 0
 957 00b6 212C      		mov r2,__zero_reg__
 958 00b8 312C      		mov r3,__zero_reg__
 959 00ba 2101      		movw r4,r2
 960 00bc 41E0      		ldi r20,lo8(1)
 961 00be 50E0      		ldi r21,0
 538:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 962               		.loc 1 538 0
 963 00c0 C85D      		subi r28,lo8(-296)
 964 00c2 DE4F      		sbci r29,hi8(-296)
 965 00c4 1882      		st Y,__zero_reg__
 966 00c6 C852      		subi r28,lo8(296)
 967 00c8 D140      		sbci r29,hi8(296)
 537:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 968               		.loc 1 537 0
 969 00ca B12C      		mov r11,__zero_reg__
 762:stk500boot.c  **** 						checksum		^=	c;
 970               		.loc 1 762 0
 971 00cc 9E01      		movw r18,r28
 972 00ce 2F5F      		subi r18,-1
 973 00d0 3F4F      		sbci r19,-1
 974 00d2 3901      		movw r6,r18
 975               	.LVL89:
 976               	.L48:
 581:stk500boot.c  **** 	boot_state	=	0;
 977               		.loc 1 581 0
 978 00d4 30E0      		ldi r19,0
 979 00d6 20E0      		ldi r18,0
 980 00d8 80E0      		ldi r24,0
 981 00da 00C0      		rjmp .L193
 982               	.LVL90:
 983               	.L47:
 984               	.LBB162:
 985               	.LBB163:
 986               		.loc 2 187 0
 987 00dc 25E0      		ldi r18,lo8(5)
 988 00de 2A95      	1:	dec r18
 989 00e0 01F4      		brne 1b
 990 00e2 0000      		nop
 991               	.LVL91:
 992               	.LBE163:
 993               	.LBE162:
 646:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 994               		.loc 1 646 0
 995 00e4 3FEF      		ldi r19,-1
 996 00e6 C31A      		sub r12,r19
 997 00e8 D30A      		sbc r13,r19
 998 00ea E30A      		sbc r14,r19
 999 00ec F30A      		sbc r15,r19
 1000               	.LVL92:
 647:stk500boot.c  **** 			{
 1001               		.loc 1 647 0
 1002 00ee 91E0      		ldi r25,lo8(1)
 1003 00f0 80E0      		ldi r24,0
 1004 00f2 41E2      		ldi r20,33
 1005 00f4 C416      		cp r12,r20
 1006 00f6 4EE4      		ldi r20,78
 1007 00f8 D406      		cpc r13,r20
 1008 00fa E104      		cpc r14,__zero_reg__
 1009 00fc F104      		cpc r15,__zero_reg__
 1010 00fe 00F4      		brsh .L44
 1011 0100 90E0      		ldi r25,0
 1012               	.L44:
 649:stk500boot.c  **** 			}
 1013               		.loc 1 649 0
 1014 0102 092F      		mov r16,r25
 1015               	.LVL93:
 1016 0104 182F      		mov r17,r24
 652:stk500boot.c  **** 			{
 1017               		.loc 1 652 0
 1018 0106 C701      		movw r24,r14
 1019 0108 B601      		movw r22,r12
 1020 010a A501      		movw r20,r10
 1021 010c 9401      		movw r18,r8
 1022 010e 0E94 0000 		call __udivmodsi4
 1023 0112 672B      		or r22,r23
 1024 0114 682B      		or r22,r24
 1025 0116 692B      		or r22,r25
 1026 0118 01F0      		breq .+2
 1027 011a 00C0      		rjmp .L43
 655:stk500boot.c  **** 			}
 1028               		.loc 1 655 0
 1029 011c 85B1      		in r24,0x5
 1030 011e 8058      		subi r24,lo8(-(-128))
 1031 0120 85B9      		out 0x5,r24
 1032 0122 00C0      		rjmp .L43
 1033               	.LVL94:
 1034               	.L54:
 1035 0124 4150      		subi r20,1
 1036 0126 5109      		sbc r21,__zero_reg__
 1037 0128 6109      		sbc r22,__zero_reg__
 1038 012a 7109      		sbc r23,__zero_reg__
 1039               	.LVL95:
 1040               	.LBB164:
 1041               	.LBB165:
 504:stk500boot.c  **** 		{
 1042               		.loc 1 504 0
 1043 012c 01F4      		brne .L52
 1044               	.LVL96:
 1045               	.LBB166:
 1046               	.LBB167:
 508:stk500boot.c  **** 		#else
 1047               		.loc 1 508 0
 1048               	/* #APP */
 1049               	 ;  508 "stk500boot.c" 1
 1050 012e 6BBF      		out 59, r22
 1051 0130 FA01      		movw r30, r20
 1052 0132 4791      		elpm r20, Z+
 1053 0134 5691      		elpm r21, Z
 1054               		
 1055               	 ;  0 "" 2
 1056               	.LVL97:
 1057               	/* #NOAPP */
 1058               	.LBE167:
 512:stk500boot.c  **** 			{
 1059               		.loc 1 512 0
 1060 0136 4F3F      		cpi r20,-1
 1061 0138 5F4F      		sbci r21,-1
 1062 013a 01F0      		breq .L53
 514:stk500boot.c  **** 						"clr	r30		\n\t"
 1063               		.loc 1 514 0
 1064               	/* #APP */
 1065               	 ;  514 "stk500boot.c" 1
 1066 013c EE27      		clr	r30		
 1067 013e FF27      		clr	r31		
 1068 0140 0994      		ijmp	
 1069               		
 1070               	 ;  0 "" 2
 1071               	.LVL98:
 1072               	/* #NOAPP */
 1073               	.L53:
 1074               	.LBE166:
 1075               	.LBE165:
 1076               	.LBE164:
 581:stk500boot.c  **** 	boot_state	=	0;
 1077               		.loc 1 581 0
 1078 0142 41E0      		ldi r20,lo8(1)
 1079 0144 52E1      		ldi r21,lo8(18)
 1080 0146 6AE7      		ldi r22,lo8(122)
 1081 0148 70E0      		ldi r23,0
 1082               	.L52:
 1083               	.LVL99:
 1084               	.LBB170:
 1085               	.LBB168:
 500:stk500boot.c  **** 	{
 1086               		.loc 1 500 0
 1087 014a 9091 C800 		lds r25,200
 1088 014e 97FF      		sbrs r25,7
 1089 0150 00C0      		rjmp .L54
 1090 0152 00C0      		rjmp .L270
 1091               	.LVL100:
 1092               	.L65:
 1093               	.LBE168:
 1094               	.LBE170:
 1095               	.LBB171:
 1096               	.LBB172:
1753:stk500boot.c  **** 
1754:stk500boot.c  **** //************************************************************************
1755:stk500boot.c  **** static void	ListAvailablePorts(void)
1756:stk500boot.c  **** {
1757:stk500boot.c  **** 
1758:stk500boot.c  **** #ifdef DDRA
1759:stk500boot.c  **** 	PrintAvailablePort('A');
1760:stk500boot.c  **** #endif
1761:stk500boot.c  **** 
1762:stk500boot.c  **** #ifdef DDRB
1763:stk500boot.c  **** 	PrintAvailablePort('B');
1764:stk500boot.c  **** #endif
1765:stk500boot.c  **** 
1766:stk500boot.c  **** #ifdef DDRC
1767:stk500boot.c  **** 	PrintAvailablePort('C');
1768:stk500boot.c  **** #endif
1769:stk500boot.c  **** 
1770:stk500boot.c  **** #ifdef DDRD
1771:stk500boot.c  **** 	PrintAvailablePort('D');
1772:stk500boot.c  **** #endif
1773:stk500boot.c  **** 
1774:stk500boot.c  **** #ifdef DDRE
1775:stk500boot.c  **** 	PrintAvailablePort('E');
1776:stk500boot.c  **** #endif
1777:stk500boot.c  **** 
1778:stk500boot.c  **** #ifdef DDRF
1779:stk500boot.c  **** 	PrintAvailablePort('F');
1780:stk500boot.c  **** #endif
1781:stk500boot.c  **** 
1782:stk500boot.c  **** #ifdef DDRG
1783:stk500boot.c  **** 	PrintAvailablePort('G');
1784:stk500boot.c  **** #endif
1785:stk500boot.c  **** 
1786:stk500boot.c  **** #ifdef DDRH
1787:stk500boot.c  **** 	PrintAvailablePort('H');
1788:stk500boot.c  **** #endif
1789:stk500boot.c  **** 
1790:stk500boot.c  **** #ifdef DDRI
1791:stk500boot.c  **** 	PrintAvailablePort('I');
1792:stk500boot.c  **** #endif
1793:stk500boot.c  **** 
1794:stk500boot.c  **** #ifdef DDRJ
1795:stk500boot.c  **** 	PrintAvailablePort('J');
1796:stk500boot.c  **** #endif
1797:stk500boot.c  **** 
1798:stk500boot.c  **** #ifdef DDRK
1799:stk500boot.c  **** 	PrintAvailablePort('K');
1800:stk500boot.c  **** #endif
1801:stk500boot.c  **** 
1802:stk500boot.c  **** #ifdef DDRL
1803:stk500boot.c  **** 	PrintAvailablePort('L');
1804:stk500boot.c  **** #endif
1805:stk500boot.c  **** 
1806:stk500boot.c  **** }
1807:stk500boot.c  **** 
1808:stk500boot.c  **** //************************************************************************
1809:stk500boot.c  **** static void	AVR_PortOutput(void)
1810:stk500boot.c  **** {
1811:stk500boot.c  **** char	portLetter;
1812:stk500boot.c  **** char	getCharFlag;
1813:stk500boot.c  **** 
1814:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
1815:stk500boot.c  **** 
1816:stk500boot.c  **** 	portLetter	=	recchar();
1817:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
1818:stk500boot.c  **** 	sendchar(portLetter);
1819:stk500boot.c  **** 	PrintNewLine();
1820:stk500boot.c  **** 
1821:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
1822:stk500boot.c  **** 	{
1823:stk500boot.c  **** 		getCharFlag	=	true;
1824:stk500boot.c  **** 		switch(portLetter)
1825:stk500boot.c  **** 		{
1826:stk500boot.c  **** 		#ifdef DDRA
1827:stk500boot.c  **** 			case 'A':
1828:stk500boot.c  **** 				DDRA	=	0xff;
1829:stk500boot.c  **** 				while (!Serial_Available())
1830:stk500boot.c  **** 				{
1831:stk500boot.c  **** 					PORTA	^=	0xff;
1832:stk500boot.c  **** 					delay_ms(200);
1833:stk500boot.c  **** 				}
1834:stk500boot.c  **** 				PORTA	=	0;
1835:stk500boot.c  **** 				break;
1836:stk500boot.c  **** 		#endif
1837:stk500boot.c  **** 
1838:stk500boot.c  **** 		#ifdef DDRB
1839:stk500boot.c  **** 			case 'B':
1840:stk500boot.c  **** 				DDRB	=	0xff;
1841:stk500boot.c  **** 				while (!Serial_Available())
1842:stk500boot.c  **** 				{
1843:stk500boot.c  **** 					PORTB	^=	0xff;
1844:stk500boot.c  **** 					delay_ms(200);
1845:stk500boot.c  **** 				}
1846:stk500boot.c  **** 				PORTB	=	0;
1847:stk500boot.c  **** 				break;
1848:stk500boot.c  **** 		#endif
1849:stk500boot.c  **** 
1850:stk500boot.c  **** 		#ifdef DDRC
1851:stk500boot.c  **** 			case 'C':
1852:stk500boot.c  **** 				DDRC	=	0xff;
1853:stk500boot.c  **** 				while (!Serial_Available())
1854:stk500boot.c  **** 				{
1855:stk500boot.c  **** 					PORTC	^=	0xff;
1856:stk500boot.c  **** 					delay_ms(200);
1857:stk500boot.c  **** 				}
1858:stk500boot.c  **** 				PORTC	=	0;
1859:stk500boot.c  **** 				break;
1860:stk500boot.c  **** 		#endif
1861:stk500boot.c  **** 
1862:stk500boot.c  **** 		#ifdef DDRD
1863:stk500boot.c  **** 			case 'D':
1864:stk500boot.c  **** 				DDRD	=	0xff;
1865:stk500boot.c  **** 				while (!Serial_Available())
1866:stk500boot.c  **** 				{
1867:stk500boot.c  **** 					PORTD	^=	0xff;
1868:stk500boot.c  **** 					delay_ms(200);
1869:stk500boot.c  **** 				}
1870:stk500boot.c  **** 				PORTD	=	0;
1871:stk500boot.c  **** 				break;
1872:stk500boot.c  **** 		#endif
1873:stk500boot.c  **** 
1874:stk500boot.c  **** 		#ifdef DDRE
1875:stk500boot.c  **** 			case 'E':
1876:stk500boot.c  **** 				DDRE	=	0xff;
1877:stk500boot.c  **** 				while (!Serial_Available())
1878:stk500boot.c  **** 				{
1879:stk500boot.c  **** 					PORTE	^=	0xff;
1880:stk500boot.c  **** 					delay_ms(200);
1881:stk500boot.c  **** 				}
1882:stk500boot.c  **** 				PORTE	=	0;
1883:stk500boot.c  **** 				break;
1884:stk500boot.c  **** 		#endif
1885:stk500boot.c  **** 
1886:stk500boot.c  **** 		#ifdef DDRF
1887:stk500boot.c  **** 			case 'F':
1888:stk500boot.c  **** 				DDRF	=	0xff;
1889:stk500boot.c  **** 				while (!Serial_Available())
1890:stk500boot.c  **** 				{
1891:stk500boot.c  **** 					PORTF	^=	0xff;
1892:stk500boot.c  **** 					delay_ms(200);
1893:stk500boot.c  **** 				}
1894:stk500boot.c  **** 				PORTF	=	0;
1895:stk500boot.c  **** 				break;
1896:stk500boot.c  **** 		#endif
1897:stk500boot.c  **** 
1898:stk500boot.c  **** 		#ifdef DDRG
1899:stk500boot.c  **** 			case 'G':
1900:stk500boot.c  **** 				DDRG	=	0xff;
1901:stk500boot.c  **** 				while (!Serial_Available())
1902:stk500boot.c  **** 				{
1903:stk500boot.c  **** 					PORTG	^=	0xff;
1904:stk500boot.c  **** 					delay_ms(200);
1905:stk500boot.c  **** 				}
1906:stk500boot.c  **** 				PORTG	=	0;
1907:stk500boot.c  **** 				break;
1908:stk500boot.c  **** 		#endif
1909:stk500boot.c  **** 
1910:stk500boot.c  **** 		#ifdef DDRH
1911:stk500boot.c  **** 			case 'H':
1912:stk500boot.c  **** 				DDRH	=	0xff;
1913:stk500boot.c  **** 				while (!Serial_Available())
1914:stk500boot.c  **** 				{
1915:stk500boot.c  **** 					PORTH	^=	0xff;
1916:stk500boot.c  **** 					delay_ms(200);
1917:stk500boot.c  **** 				}
1918:stk500boot.c  **** 				PORTH	=	0;
1919:stk500boot.c  **** 				break;
1920:stk500boot.c  **** 		#endif
1921:stk500boot.c  **** 
1922:stk500boot.c  **** 		#ifdef DDRI
1923:stk500boot.c  **** 			case 'I':
1924:stk500boot.c  **** 				DDRI	=	0xff;
1925:stk500boot.c  **** 				while (!Serial_Available())
1926:stk500boot.c  **** 				{
1927:stk500boot.c  **** 					PORTI	^=	0xff;
1928:stk500boot.c  **** 					delay_ms(200);
1929:stk500boot.c  **** 				}
1930:stk500boot.c  **** 				PORTI	=	0;
1931:stk500boot.c  **** 				break;
1932:stk500boot.c  **** 		#endif
1933:stk500boot.c  **** 
1934:stk500boot.c  **** 		#ifdef DDRJ
1935:stk500boot.c  **** 			case 'J':
1936:stk500boot.c  **** 				DDRJ	=	0xff;
1937:stk500boot.c  **** 				while (!Serial_Available())
1938:stk500boot.c  **** 				{
1939:stk500boot.c  **** 					PORTJ	^=	0xff;
1940:stk500boot.c  **** 					delay_ms(200);
1941:stk500boot.c  **** 				}
1942:stk500boot.c  **** 				PORTJ	=	0;
1943:stk500boot.c  **** 				break;
1944:stk500boot.c  **** 		#endif
1945:stk500boot.c  **** 
1946:stk500boot.c  **** 		#ifdef DDRK
1947:stk500boot.c  **** 			case 'K':
1948:stk500boot.c  **** 				DDRK	=	0xff;
1949:stk500boot.c  **** 				while (!Serial_Available())
1950:stk500boot.c  **** 				{
1951:stk500boot.c  **** 					PORTK	^=	0xff;
1952:stk500boot.c  **** 					delay_ms(200);
1953:stk500boot.c  **** 				}
1954:stk500boot.c  **** 				PORTK	=	0;
1955:stk500boot.c  **** 				break;
1956:stk500boot.c  **** 		#endif
1957:stk500boot.c  **** 
1958:stk500boot.c  **** 		#ifdef DDRL
1959:stk500boot.c  **** 			case 'L':
1960:stk500boot.c  **** 				DDRL	=	0xff;
1961:stk500boot.c  **** 				while (!Serial_Available())
1962:stk500boot.c  **** 				{
1963:stk500boot.c  **** 					PORTL	^=	0xff;
1964:stk500boot.c  **** 					delay_ms(200);
1965:stk500boot.c  **** 				}
1966:stk500boot.c  **** 				PORTL	=	0;
1967:stk500boot.c  **** 				break;
1968:stk500boot.c  **** 		#endif
1969:stk500boot.c  **** 
1970:stk500boot.c  **** 			default:
1971:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
1972:stk500boot.c  **** 				getCharFlag	=	false;
1973:stk500boot.c  **** 				break;
1974:stk500boot.c  **** 		}
1975:stk500boot.c  **** 		if (getCharFlag)
1976:stk500boot.c  **** 		{
1977:stk500boot.c  **** 			recchar();
1978:stk500boot.c  **** 		}
1979:stk500boot.c  **** 	}
1980:stk500boot.c  **** 	else
1981:stk500boot.c  **** 	{
1982:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
1983:stk500boot.c  **** 	}
1984:stk500boot.c  **** }
1985:stk500boot.c  **** 
1986:stk500boot.c  **** 
1987:stk500boot.c  **** //*******************************************************************
1988:stk500boot.c  **** static void PrintHelp(void)
1989:stk500boot.c  **** {
1990:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
1991:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
1992:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
1993:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
1994:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
1995:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
1996:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
1997:stk500boot.c  **** 
1998:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
1999:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
2000:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
2001:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
2002:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
2003:stk500boot.c  **** }
2004:stk500boot.c  **** 
2005:stk500boot.c  **** //************************************************************************
2006:stk500boot.c  **** static void	RunMonitor(void)
2007:stk500boot.c  **** {
2008:stk500boot.c  **** char			keepGoing;
2009:stk500boot.c  **** unsigned char	theChar;
2010:stk500boot.c  **** int				ii, jj;
2011:stk500boot.c  **** 
2012:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
2013:stk500boot.c  **** 	{
2014:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
2015:stk500boot.c  **** 		{
2016:stk500boot.c  **** 			sendchar('!');
2017:stk500boot.c  **** 		}
2018:stk500boot.c  **** 		PrintNewLine();
2019:stk500boot.c  **** 	}
2020:stk500boot.c  **** 
2021:stk500boot.c  **** 	gRamIndex			=	0;
2022:stk500boot.c  **** 	gFlashIndex			=	0;
2023:stk500boot.c  **** 	gEepromIndex		=	0;
2024:stk500boot.c  **** 
2025:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
2026:stk500boot.c  **** 
2027:stk500boot.c  **** 	keepGoing	=	1;
2028:stk500boot.c  **** 	while (keepGoing)
2029:stk500boot.c  **** 	{
2030:stk500boot.c  **** 		PrintFromPROGMEM(gTextMsg_Prompt, 0);
2031:stk500boot.c  **** 		theChar	=	recchar();
2032:stk500boot.c  **** 		if (theChar >= 0x60)
2033:stk500boot.c  **** 		{
2034:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
2035:stk500boot.c  **** 		}
2036:stk500boot.c  **** 
2037:stk500boot.c  **** 		if (theChar >= 0x20)
2038:stk500boot.c  **** 		{
2039:stk500boot.c  **** 			sendchar(theChar);
2040:stk500boot.c  **** 			sendchar(0x20);
2041:stk500boot.c  **** 		}
2042:stk500boot.c  **** 
2043:stk500boot.c  **** 		switch(theChar)
 1097               		.loc 1 2043 0
 1098 0154 1234      		cpi r17,lo8(66)
 1099 0156 01F4      		brne .+2
 1100 0158 00C0      		rjmp .L68
 1101 015a 1534      		cpi r17,lo8(69)
 1102 015c 01F0      		breq .+2
 1103 015e 00C0      		rjmp .L61
2044:stk500boot.c  **** 		{
2045:stk500boot.c  **** 			case '0':
2046:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
2047:stk500boot.c  **** 				gFlashIndex		=	0;
2048:stk500boot.c  **** 				gRamIndex		=	0;
2049:stk500boot.c  **** 				gEepromIndex	=	0;
2050:stk500boot.c  **** 				break;
2051:stk500boot.c  **** 
2052:stk500boot.c  **** 			case '?':
2053:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
2054:stk500boot.c  **** 				PrintCPUstats();
2055:stk500boot.c  **** 				break;
2056:stk500boot.c  **** 
2057:stk500boot.c  **** 			case '@':
2058:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
2059:stk500boot.c  **** 				EEPROMtest();
2060:stk500boot.c  **** 				break;
2061:stk500boot.c  **** 
2062:stk500boot.c  **** 			case 'B':
2063:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
2064:stk500boot.c  **** 				BlinkLED();
2065:stk500boot.c  **** 				break;
2066:stk500boot.c  **** 
2067:stk500boot.c  **** 			case 'E':
2068:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
 1104               		.loc 1 2068 0
 1105 0160 62E0      		ldi r22,lo8(2)
 1106 0162 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1107 0164 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1108 0166 0E94 0000 		call PrintFromPROGMEMln
 1109               	.LVL101:
2069:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 1110               		.loc 1 2069 0
 1111 016a 4091 0000 		lds r20,gEepromIndex
 1112 016e 5091 0000 		lds r21,gEepromIndex+1
 1113 0172 6091 0000 		lds r22,gEepromIndex+2
 1114 0176 7091 0000 		lds r23,gEepromIndex+3
 1115 017a 81E0      		ldi r24,lo8(1)
 1116 017c 0E94 0000 		call DumpHex.constprop.0
 1117               	.LVL102:
2070:stk500boot.c  **** 				gEepromIndex	+=	256;
 1118               		.loc 1 2070 0
 1119 0180 8091 0000 		lds r24,gEepromIndex
 1120 0184 9091 0000 		lds r25,gEepromIndex+1
 1121 0188 A091 0000 		lds r26,gEepromIndex+2
 1122 018c B091 0000 		lds r27,gEepromIndex+3
 1123 0190 9F5F      		subi r25,-1
 1124 0192 AF4F      		sbci r26,-1
 1125 0194 BF4F      		sbci r27,-1
 1126 0196 8093 0000 		sts gEepromIndex,r24
 1127 019a 9093 0000 		sts gEepromIndex+1,r25
 1128 019e A093 0000 		sts gEepromIndex+2,r26
 1129 01a2 B093 0000 		sts gEepromIndex+3,r27
2071:stk500boot.c  **** 				if (gEepromIndex > E2END)
 1130               		.loc 1 2071 0
 1131 01a6 8115      		cp r24,__zero_reg__
 1132 01a8 9041      		sbci r25,16
 1133 01aa A105      		cpc r26,__zero_reg__
 1134 01ac B105      		cpc r27,__zero_reg__
 1135 01ae 00F4      		brsh .+2
 1136 01b0 00C0      		rjmp .L60
 1137 01b2 00C0      		rjmp .L273
 1138               	.L63:
2043:stk500boot.c  **** 		{
 1139               		.loc 1 2043 0
 1140 01b4 1135      		cpi r17,lo8(81)
 1141 01b6 01F4      		brne .+2
 1142 01b8 00C0      		rjmp .L70
 1143 01ba 00F4      		brsh .L71
 1144 01bc 1834      		cpi r17,lo8(72)
 1145 01be 01F4      		brne .+2
 1146 01c0 00C0      		rjmp .L72
 1147 01c2 1C34      		cpi r17,lo8(76)
 1148 01c4 01F0      		breq .+2
 1149 01c6 00C0      		rjmp .L61
2072:stk500boot.c  **** 				{
2073:stk500boot.c  **** 					gEepromIndex	=	0;
2074:stk500boot.c  **** 				}
2075:stk500boot.c  **** 				break;
2076:stk500boot.c  **** 		
2077:stk500boot.c  **** 			case 'F':
2078:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
2079:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
2080:stk500boot.c  **** 				gFlashIndex	+=	256;
2081:stk500boot.c  **** 				break;
2082:stk500boot.c  **** 
2083:stk500boot.c  **** 			case 'H':
2084:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
2085:stk500boot.c  **** 				PrintHelp();
2086:stk500boot.c  **** 				break;
2087:stk500boot.c  **** 
2088:stk500boot.c  **** 			case 'L':
2089:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
 1150               		.loc 1 2089 0
 1151 01c8 62E0      		ldi r22,lo8(2)
 1152 01ca 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1153 01cc 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1154 01ce 0E94 0000 		call PrintFromPROGMEMln
 1155               	.LVL103:
 1156               	.LBB173:
 1157               	.LBB174:
1759:stk500boot.c  **** #endif
 1158               		.loc 1 1759 0
 1159 01d2 81E4      		ldi r24,lo8(65)
 1160 01d4 0E94 0000 		call PrintAvailablePort
 1161               	.LVL104:
1763:stk500boot.c  **** #endif
 1162               		.loc 1 1763 0
 1163 01d8 82E4      		ldi r24,lo8(66)
 1164 01da 0E94 0000 		call PrintAvailablePort
 1165               	.LVL105:
1767:stk500boot.c  **** #endif
 1166               		.loc 1 1767 0
 1167 01de 83E4      		ldi r24,lo8(67)
 1168 01e0 0E94 0000 		call PrintAvailablePort
 1169               	.LVL106:
1771:stk500boot.c  **** #endif
 1170               		.loc 1 1771 0
 1171 01e4 84E4      		ldi r24,lo8(68)
 1172 01e6 0E94 0000 		call PrintAvailablePort
 1173               	.LVL107:
1775:stk500boot.c  **** #endif
 1174               		.loc 1 1775 0
 1175 01ea 85E4      		ldi r24,lo8(69)
 1176 01ec 0E94 0000 		call PrintAvailablePort
 1177               	.LVL108:
1779:stk500boot.c  **** #endif
 1178               		.loc 1 1779 0
 1179 01f0 86E4      		ldi r24,lo8(70)
 1180 01f2 0E94 0000 		call PrintAvailablePort
 1181               	.LVL109:
1783:stk500boot.c  **** #endif
 1182               		.loc 1 1783 0
 1183 01f6 87E4      		ldi r24,lo8(71)
 1184 01f8 0E94 0000 		call PrintAvailablePort
 1185               	.LVL110:
1787:stk500boot.c  **** #endif
 1186               		.loc 1 1787 0
 1187 01fc 88E4      		ldi r24,lo8(72)
 1188 01fe 0E94 0000 		call PrintAvailablePort
 1189               	.LVL111:
1795:stk500boot.c  **** #endif
 1190               		.loc 1 1795 0
 1191 0202 8AE4      		ldi r24,lo8(74)
 1192 0204 0E94 0000 		call PrintAvailablePort
 1193               	.LVL112:
1799:stk500boot.c  **** #endif
 1194               		.loc 1 1799 0
 1195 0208 8BE4      		ldi r24,lo8(75)
 1196 020a 0E94 0000 		call PrintAvailablePort
 1197               	.LVL113:
1803:stk500boot.c  **** #endif
 1198               		.loc 1 1803 0
 1199 020e 8CE4      		ldi r24,lo8(76)
 1200 0210 0E94 0000 		call PrintAvailablePort
 1201               	.LVL114:
 1202 0214 00C0      		rjmp .L60
 1203               	.L71:
 1204               	.LBE174:
 1205               	.LBE173:
2043:stk500boot.c  **** 		{
 1206               		.loc 1 2043 0
 1207 0216 1635      		cpi r17,lo8(86)
 1208 0218 01F4      		brne .+2
 1209 021a 00C0      		rjmp .L74
 1210 021c 1935      		cpi r17,lo8(89)
 1211 021e 01F4      		brne .+2
 1212 0220 00C0      		rjmp .L75
 1213 0222 1235      		cpi r17,lo8(82)
 1214 0224 01F0      		breq .+2
 1215 0226 00C0      		rjmp .L61
2090:stk500boot.c  **** 				ListAvailablePorts();
2091:stk500boot.c  **** 				break;
2092:stk500boot.c  **** 
2093:stk500boot.c  **** 			case 'Q':
2094:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
2095:stk500boot.c  **** 				keepGoing	=	false;
2096:stk500boot.c  **** 				break;
2097:stk500boot.c  **** 
2098:stk500boot.c  **** 			case 'R':
2099:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
 1216               		.loc 1 2099 0
 1217 0228 62E0      		ldi r22,lo8(2)
 1218 022a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1219 022c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1220 022e 0E94 0000 		call PrintFromPROGMEMln
 1221               	.LVL115:
2100:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 1222               		.loc 1 2100 0
 1223 0232 4091 0000 		lds r20,gRamIndex
 1224 0236 5091 0000 		lds r21,gRamIndex+1
 1225 023a 6091 0000 		lds r22,gRamIndex+2
 1226 023e 7091 0000 		lds r23,gRamIndex+3
 1227 0242 82E0      		ldi r24,lo8(2)
 1228 0244 0E94 0000 		call DumpHex.constprop.0
 1229               	.LVL116:
2101:stk500boot.c  **** 				gRamIndex	+=	256;
 1230               		.loc 1 2101 0
 1231 0248 8091 0000 		lds r24,gRamIndex
 1232 024c 9091 0000 		lds r25,gRamIndex+1
 1233 0250 A091 0000 		lds r26,gRamIndex+2
 1234 0254 B091 0000 		lds r27,gRamIndex+3
 1235 0258 9F5F      		subi r25,-1
 1236 025a AF4F      		sbci r26,-1
 1237 025c BF4F      		sbci r27,-1
 1238 025e 8093 0000 		sts gRamIndex,r24
 1239 0262 9093 0000 		sts gRamIndex+1,r25
 1240 0266 A093 0000 		sts gRamIndex+2,r26
 1241 026a B093 0000 		sts gRamIndex+3,r27
 1242 026e 00C0      		rjmp .L60
 1243               	.L66:
2046:stk500boot.c  **** 				gFlashIndex		=	0;
 1244               		.loc 1 2046 0
 1245 0270 62E0      		ldi r22,lo8(2)
 1246 0272 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1247 0274 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1248 0276 0E94 0000 		call PrintFromPROGMEMln
 1249               	.LVL117:
2047:stk500boot.c  **** 				gRamIndex		=	0;
 1250               		.loc 1 2047 0
 1251 027a 1092 0000 		sts gFlashIndex,__zero_reg__
 1252 027e 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1253 0282 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1254 0286 1092 0000 		sts gFlashIndex+3,__zero_reg__
2048:stk500boot.c  **** 				gEepromIndex	=	0;
 1255               		.loc 1 2048 0
 1256 028a 1092 0000 		sts gRamIndex,__zero_reg__
 1257 028e 1092 0000 		sts gRamIndex+1,__zero_reg__
 1258 0292 1092 0000 		sts gRamIndex+2,__zero_reg__
 1259 0296 1092 0000 		sts gRamIndex+3,__zero_reg__
 1260               	.LVL118:
 1261               	.L273:
 1262               	.LBB175:
 1263               	.LBB176:
1609:stk500boot.c  **** 
 1264               		.loc 1 1609 0
 1265 029a 1092 0000 		sts gEepromIndex,__zero_reg__
 1266 029e 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1267 02a2 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1268 02a6 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1269 02aa 00C0      		rjmp .L60
 1270               	.LVL119:
 1271               	.L67:
 1272               	.LBE176:
 1273               	.LBE175:
2053:stk500boot.c  **** 				PrintCPUstats();
 1274               		.loc 1 2053 0
 1275 02ac 62E0      		ldi r22,lo8(2)
 1276 02ae 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1277 02b0 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1278 02b2 0E94 0000 		call PrintFromPROGMEMln
 1279               	.LVL120:
 1280               	.LBB180:
 1281               	.LBB181:
1395:stk500boot.c  **** 
 1282               		.loc 1 1395 0
 1283 02b6 60E0      		ldi r22,0
 1284 02b8 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1285 02ba 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1286 02bc 0E94 0000 		call PrintFromPROGMEMln
 1287               	.LVL121:
1397:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
 1288               		.loc 1 1397 0
 1289 02c0 60E0      		ldi r22,0
 1290 02c2 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 1291 02c4 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 1292 02c6 0E94 0000 		call PrintFromPROGMEM
 1293               	.LVL122:
1398:stk500boot.c  **** 
 1294               		.loc 1 1398 0
 1295 02ca 60E0      		ldi r22,0
 1296 02cc 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 1297 02ce 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 1298 02d0 0E94 0000 		call PrintFromPROGMEMln
 1299               	.LVL123:
1400:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1300               		.loc 1 1400 0
 1301 02d4 60E0      		ldi r22,0
 1302 02d6 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 1303 02d8 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 1304 02da 0E94 0000 		call PrintFromPROGMEM
 1305               	.LVL124:
1401:stk500boot.c  **** 
 1306               		.loc 1 1401 0
 1307 02de 60E0      		ldi r22,0
 1308 02e0 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1309 02e2 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1310 02e4 0E94 0000 		call PrintFromPROGMEMln
 1311               	.LVL125:
1403:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
 1312               		.loc 1 1403 0
 1313 02e8 60E0      		ldi r22,0
 1314 02ea 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 1315 02ec 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 1316 02ee 0E94 0000 		call PrintFromPROGMEM
 1317               	.LVL126:
 1318               	.LBB182:
 1319               	.LBB183:
1384:stk500boot.c  **** }
 1320               		.loc 1 1384 0
 1321 02f2 86E3      		ldi r24,lo8(54)
 1322 02f4 0E94 0000 		call sendchar
 1323               	.LVL127:
 1324               	.LBE183:
 1325               	.LBE182:
1405:stk500boot.c  **** 
 1326               		.loc 1 1405 0
 1327 02f8 0E94 0000 		call PrintNewLine
 1328               	.LVL128:
1407:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
 1329               		.loc 1 1407 0
 1330 02fc 60E0      		ldi r22,0
 1331 02fe 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 1332 0300 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 1333 0302 0E94 0000 		call PrintFromPROGMEM
 1334               	.LVL129:
1408:stk500boot.c  **** 
 1335               		.loc 1 1408 0
 1336 0306 60E0      		ldi r22,0
 1337 0308 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 1338 030a 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 1339 030c 0E94 0000 		call PrintFromPROGMEMln
 1340               	.LVL130:
1411:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
 1341               		.loc 1 1411 0
 1342 0310 60E0      		ldi r22,0
 1343 0312 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 1344 0314 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 1345 0316 0E94 0000 		call PrintFromPROGMEM
 1346               	.LVL131:
1412:stk500boot.c  **** 
 1347               		.loc 1 1412 0
 1348 031a 60E0      		ldi r22,0
 1349 031c 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 1350 031e 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 1351 0320 0E94 0000 		call PrintFromPROGMEMln
 1352               	.LVL132:
1415:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
 1353               		.loc 1 1415 0
 1354 0324 60E0      		ldi r22,0
 1355 0326 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 1356 0328 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 1357 032a 0E94 0000 		call PrintFromPROGMEM
 1358               	.LVL133:
1417:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 1359               		.loc 1 1417 0
 1360 032e 8EE1      		ldi r24,lo8(30)
 1361 0330 0E94 0000 		call PrintHexByte
 1362               	.LVL134:
1418:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 1363               		.loc 1 1418 0
 1364 0334 88E9      		ldi r24,lo8(-104)
 1365 0336 0E94 0000 		call PrintHexByte
 1366               	.LVL135:
1419:stk500boot.c  **** 	PrintNewLine();
 1367               		.loc 1 1419 0
 1368 033a 81E0      		ldi r24,lo8(1)
 1369 033c 0E94 0000 		call PrintHexByte
 1370               	.LVL136:
1420:stk500boot.c  **** #endif
 1371               		.loc 1 1420 0
 1372 0340 0E94 0000 		call PrintNewLine
 1373               	.LVL137:
1426:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1374               		.loc 1 1426 0
 1375 0344 60E0      		ldi r22,0
 1376 0346 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 1377 0348 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 1378 034a 0E94 0000 		call PrintFromPROGMEM
 1379               	.LVL138:
 1380               	.LBB184:
1427:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1381               		.loc 1 1427 0
 1382 034e 29E0      		ldi r18,lo8(9)
 1383 0350 F0E0      		ldi r31,0
 1384 0352 E0E0      		ldi r30,0
 1385               	/* #APP */
 1386               	 ;  1427 "stk500boot.c" 1
 1387 0354 2093 5700 		sts 87, r18
 1388 0358 8491      		lpm r24, Z
 1389               		
 1390               	 ;  0 "" 2
 1391               	.LVL139:
 1392               	/* #NOAPP */
 1393               	.LBE184:
1428:stk500boot.c  **** 	PrintNewLine();
 1394               		.loc 1 1428 0
 1395 035a 0E94 0000 		call PrintHexByte
 1396               	.LVL140:
1429:stk500boot.c  **** 
 1397               		.loc 1 1429 0
 1398 035e 0E94 0000 		call PrintNewLine
 1399               	.LVL141:
1431:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1400               		.loc 1 1431 0
 1401 0362 60E0      		ldi r22,0
 1402 0364 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 1403 0366 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 1404 0368 0E94 0000 		call PrintFromPROGMEM
 1405               	.LVL142:
 1406               	.LBB185:
1432:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1407               		.loc 1 1432 0
 1408 036c 29E0      		ldi r18,lo8(9)
 1409 036e E3E0      		ldi r30,lo8(3)
 1410 0370 F0E0      		ldi r31,0
 1411               	/* #APP */
 1412               	 ;  1432 "stk500boot.c" 1
 1413 0372 2093 5700 		sts 87, r18
 1414 0376 8491      		lpm r24, Z
 1415               		
 1416               	 ;  0 "" 2
 1417               	.LVL143:
 1418               	/* #NOAPP */
 1419               	.LBE185:
1433:stk500boot.c  **** 	PrintNewLine();
 1420               		.loc 1 1433 0
 1421 0378 0E94 0000 		call PrintHexByte
 1422               	.LVL144:
1434:stk500boot.c  **** 
 1423               		.loc 1 1434 0
 1424 037c 0E94 0000 		call PrintNewLine
 1425               	.LVL145:
1436:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 1426               		.loc 1 1436 0
 1427 0380 60E0      		ldi r22,0
 1428 0382 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 1429 0384 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 1430 0386 0E94 0000 		call PrintFromPROGMEM
 1431               	.LVL146:
 1432               	.LBB186:
1437:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1433               		.loc 1 1437 0
 1434 038a E2E0      		ldi r30,lo8(2)
 1435 038c F0E0      		ldi r31,0
 1436 038e 39E0      		ldi r19,lo8(9)
 1437               	/* #APP */
 1438               	 ;  1437 "stk500boot.c" 1
 1439 0390 3093 5700 		sts 87, r19
 1440 0394 8491      		lpm r24, Z
 1441               		
 1442               	 ;  0 "" 2
 1443               	.LVL147:
 1444               	/* #NOAPP */
 1445               	.LBE186:
1438:stk500boot.c  **** 	PrintNewLine();
 1446               		.loc 1 1438 0
 1447 0396 0E94 0000 		call PrintHexByte
 1448               	.LVL148:
1439:stk500boot.c  **** 
 1449               		.loc 1 1439 0
 1450 039a 0E94 0000 		call PrintNewLine
 1451               	.LVL149:
1441:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 1452               		.loc 1 1441 0
 1453 039e 60E0      		ldi r22,0
 1454 03a0 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 1455 03a2 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 1456 03a4 0E94 0000 		call PrintFromPROGMEM
 1457               	.LVL150:
 1458               	.LBB187:
1442:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1459               		.loc 1 1442 0
 1460 03a8 E1E0      		ldi r30,lo8(1)
 1461 03aa F0E0      		ldi r31,0
 1462 03ac 49E0      		ldi r20,lo8(9)
 1463               	/* #APP */
 1464               	 ;  1442 "stk500boot.c" 1
 1465 03ae 4093 5700 		sts 87, r20
 1466 03b2 8491      		lpm r24, Z
 1467               		
 1468               	 ;  0 "" 2
 1469               	.LVL151:
 1470               	/* #NOAPP */
 1471               	.LBE187:
1443:stk500boot.c  **** 	PrintNewLine();
 1472               		.loc 1 1443 0
 1473 03b4 0E94 0000 		call PrintHexByte
 1474               	.LVL152:
1444:stk500boot.c  **** 
 1475               		.loc 1 1444 0
 1476 03b8 0E94 0000 		call PrintNewLine
 1477               	.LVL153:
 1478 03bc 00C0      		rjmp .L60
 1479               	.LVL154:
 1480               	.L64:
 1481               	.LBE181:
 1482               	.LBE180:
2058:stk500boot.c  **** 				EEPROMtest();
 1483               		.loc 1 2058 0
 1484 03be 62E0      		ldi r22,lo8(2)
 1485 03c0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1486 03c2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1487 03c4 0E94 0000 		call PrintFromPROGMEMln
 1488               	.LVL155:
 1489               	.LBB188:
 1490               	.LBB179:
1553:stk500boot.c  **** 	PrintNewLine();
 1491               		.loc 1 1553 0
 1492 03c8 60E0      		ldi r22,0
 1493 03ca 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 1494 03cc 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 1495 03ce 0E94 0000 		call PrintFromPROGMEMln
 1496               	.LVL156:
1554:stk500boot.c  **** 	ii			=	0;
 1497               		.loc 1 1554 0
 1498 03d2 0E94 0000 		call PrintNewLine
 1499               	.LVL157:
1555:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1500               		.loc 1 1555 0
 1501 03d6 F12C      		mov r15,__zero_reg__
 1502 03d8 E12C      		mov r14,__zero_reg__
 1503               	.LVL158:
 1504               	.L78:
 1505               	.LBB177:
1557:stk500boot.c  **** #else
 1506               		.loc 1 1557 0
 1507 03da C701      		movw r24,r14
 1508 03dc 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1509 03de 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1510 03e0 B0E0      		ldi r27,0
 1511 03e2 A0E0      		ldi r26,0
 1512               	/* #APP */
 1513               	 ;  1557 "stk500boot.c" 1
 1514 03e4 ABBF      		out 59, r26
 1515 03e6 FC01      		movw r30, r24
 1516 03e8 1791      		elpm r17, Z+
 1517               		
 1518               	 ;  0 "" 2
 1519               	.LVL159:
 1520               	/* #NOAPP */
 1521               	.LBE177:
 1522 03ea 1A32      		cpi r17,lo8(42)
 1523 03ec 01F0      		breq .L81
 1524 03ee E114      		cp r14,__zero_reg__
 1525 03f0 82E0      		ldi r24,2
 1526 03f2 F806      		cpc r15,r24
 1527 03f4 01F4      		brne .L82
 1528               	.L81:
1575:stk500boot.c  **** 	PrintNewLine();
 1529               		.loc 1 1575 0
 1530 03f6 0E94 0000 		call PrintNewLine
 1531               	.LVL160:
1576:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
 1532               		.loc 1 1576 0
 1533 03fa 0E94 0000 		call PrintNewLine
 1534               	.LVL161:
1577:stk500boot.c  **** 	PrintNewLine();
 1535               		.loc 1 1577 0
 1536 03fe 60E0      		ldi r22,0
 1537 0400 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 1538 0402 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 1539 0404 0E94 0000 		call PrintFromPROGMEMln
 1540               	.LVL162:
1578:stk500boot.c  **** 	errorCount	=	0;
 1541               		.loc 1 1578 0
 1542 0408 0E94 0000 		call PrintNewLine
 1543               	.LVL163:
1579:stk500boot.c  **** 	ii			=	0;
 1544               		.loc 1 1579 0
 1545 040c D12C      		mov r13,__zero_reg__
 1546 040e C12C      		mov r12,__zero_reg__
1580:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1547               		.loc 1 1580 0
 1548 0410 F12C      		mov r15,__zero_reg__
 1549 0412 E12C      		mov r14,__zero_reg__
 1550               	.LVL164:
 1551               	.L83:
 1552               	.LBB178:
1582:stk500boot.c  **** #else
 1553               		.loc 1 1582 0
 1554 0414 C701      		movw r24,r14
 1555 0416 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1556 0418 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1557 041a B0E0      		ldi r27,0
 1558 041c A0E0      		ldi r26,0
 1559               	/* #APP */
 1560               	 ;  1582 "stk500boot.c" 1
 1561 041e ABBF      		out 59, r26
 1562 0420 FC01      		movw r30, r24
 1563 0422 1791      		elpm r17, Z+
 1564               		
 1565               	 ;  0 "" 2
 1566               	.LVL165:
 1567               	/* #NOAPP */
 1568               	.LBE178:
 1569 0424 1A32      		cpi r17,lo8(42)
 1570 0426 01F0      		breq .L87
 1571 0428 E114      		cp r14,__zero_reg__
 1572 042a B2E0      		ldi r27,2
 1573 042c FB06      		cpc r15,r27
 1574 042e 01F4      		brne .L88
 1575               	.L87:
1602:stk500boot.c  **** 	PrintNewLine();
 1576               		.loc 1 1602 0
 1577 0430 0E94 0000 		call PrintNewLine
 1578               	.LVL166:
1603:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
 1579               		.loc 1 1603 0
 1580 0434 0E94 0000 		call PrintNewLine
 1581               	.LVL167:
1604:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 1582               		.loc 1 1604 0
 1583 0438 60E0      		ldi r22,0
 1584 043a 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 1585 043c 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 1586 043e 0E94 0000 		call PrintFromPROGMEM
 1587               	.LVL168:
1605:stk500boot.c  **** 	PrintNewLine();
 1588               		.loc 1 1605 0
 1589 0442 61E0      		ldi r22,lo8(1)
 1590 0444 70E0      		ldi r23,0
 1591 0446 C601      		movw r24,r12
 1592 0448 0E94 0000 		call PrintDecInt
 1593               	.LVL169:
1606:stk500boot.c  **** 	PrintNewLine();
 1594               		.loc 1 1606 0
 1595 044c 0E94 0000 		call PrintNewLine
 1596               	.LVL170:
1607:stk500boot.c  **** 
 1597               		.loc 1 1607 0
 1598 0450 0E94 0000 		call PrintNewLine
 1599               	.LVL171:
 1600 0454 00C0      		rjmp .L273
 1601               	.LVL172:
 1602               	.L82:
1562:stk500boot.c  **** 		if (theChar == 0)
 1603               		.loc 1 1562 0
 1604 0456 612F      		mov r22,r17
 1605 0458 C701      		movw r24,r14
 1606 045a 0E94 0000 		call eeprom_write_byte
 1607               	.LVL173:
1563:stk500boot.c  **** 		{
 1608               		.loc 1 1563 0
 1609 045e 1111      		cpse r17,__zero_reg__
 1610 0460 00C0      		rjmp .L79
1565:stk500boot.c  **** 		}
 1611               		.loc 1 1565 0
 1612 0462 60E0      		ldi r22,0
 1613 0464 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1614 0466 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1615 0468 0E94 0000 		call PrintFromPROGMEM
 1616               	.LVL174:
 1617               	.L80:
1571:stk500boot.c  **** 	}
 1618               		.loc 1 1571 0
 1619 046c 5FEF      		ldi r21,-1
 1620 046e E51A      		sub r14,r21
 1621 0470 F50A      		sbc r15,r21
 1622               	.LVL175:
 1623 0472 00C0      		rjmp .L78
 1624               	.LVL176:
 1625               	.L79:
1569:stk500boot.c  **** 		}
 1626               		.loc 1 1569 0
 1627 0474 812F      		mov r24,r17
 1628 0476 0E94 0000 		call sendchar
 1629               	.LVL177:
 1630 047a 00C0      		rjmp .L80
 1631               	.LVL178:
 1632               	.L88:
1587:stk500boot.c  **** 		if (theEEPROMchar == 0)
 1633               		.loc 1 1587 0
 1634 047c C701      		movw r24,r14
 1635 047e 0E94 0000 		call eeprom_read_byte
 1636               	.LVL179:
 1637 0482 B82E      		mov r11,r24
 1638               	.LVL180:
1588:stk500boot.c  **** 		{
 1639               		.loc 1 1588 0
 1640 0484 8111      		cpse r24,__zero_reg__
 1641 0486 00C0      		rjmp .L84
1590:stk500boot.c  **** 		}
 1642               		.loc 1 1590 0
 1643 0488 60E0      		ldi r22,0
 1644 048a 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1645 048c 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1646 048e 0E94 0000 		call PrintFromPROGMEM
 1647               	.LVL181:
 1648               	.L85:
1596:stk500boot.c  **** 		{
 1649               		.loc 1 1596 0
 1650 0492 B116      		cp r11,r17
 1651 0494 01F0      		breq .L86
1598:stk500boot.c  **** 		}
 1652               		.loc 1 1598 0
 1653 0496 9FEF      		ldi r25,-1
 1654 0498 C91A      		sub r12,r25
 1655 049a D90A      		sbc r13,r25
 1656               	.LVL182:
 1657               	.L86:
1600:stk500boot.c  **** 	}
 1658               		.loc 1 1600 0
 1659 049c AFEF      		ldi r26,-1
 1660 049e EA1A      		sub r14,r26
 1661 04a0 FA0A      		sbc r15,r26
 1662               	.LVL183:
 1663 04a2 00C0      		rjmp .L83
 1664               	.LVL184:
 1665               	.L84:
1594:stk500boot.c  **** 		}
 1666               		.loc 1 1594 0
 1667 04a4 0E94 0000 		call sendchar
 1668               	.LVL185:
 1669 04a8 00C0      		rjmp .L85
 1670               	.LVL186:
 1671               	.L68:
 1672               	.LBE179:
 1673               	.LBE188:
2063:stk500boot.c  **** 				BlinkLED();
 1674               		.loc 1 2063 0
 1675 04aa 62E0      		ldi r22,lo8(2)
 1676 04ac 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1677 04ae 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1678 04b0 0E94 0000 		call PrintFromPROGMEMln
 1679               	.LVL187:
 1680               	.LBB189:
 1681               	.LBB190:
1454:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 1682               		.loc 1 1454 0
 1683 04b4 279A      		sbi 0x4,7
1455:stk500boot.c  **** 
 1684               		.loc 1 1455 0
 1685 04b6 2F9A      		sbi 0x5,7
 1686               	.L89:
 1687               	.LBB191:
 1688               	.LBB192:
 477:stk500boot.c  **** }
 1689               		.loc 1 477 0
 1690 04b8 8091 C800 		lds r24,200
 1691               	.LBE192:
 1692               	.LBE191:
1457:stk500boot.c  **** 	{
 1693               		.loc 1 1457 0
 1694 04bc 87FF      		sbrs r24,7
 1695 04be 00C0      		rjmp .L90
 1696               	.LVL188:
 1697               	.L116:
1464:stk500boot.c  **** }
 1698               		.loc 1 1464 0
 1699 04c0 0E94 0000 		call recchar
 1700               	.LVL189:
 1701 04c4 00C0      		rjmp .L60
 1702               	.LVL190:
 1703               	.L90:
1459:stk500boot.c  **** 		delay_ms(100);
 1704               		.loc 1 1459 0
 1705 04c6 2F98      		cbi 0x5,7
1460:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 1706               		.loc 1 1460 0
 1707 04c8 84E6      		ldi r24,lo8(100)
 1708 04ca 90E0      		ldi r25,0
 1709 04cc 0E94 0000 		call delay_ms
 1710               	.LVL191:
1461:stk500boot.c  **** 		delay_ms(100);
 1711               		.loc 1 1461 0
 1712 04d0 2F9A      		sbi 0x5,7
1462:stk500boot.c  **** 	}
 1713               		.loc 1 1462 0
 1714 04d2 84E6      		ldi r24,lo8(100)
 1715 04d4 90E0      		ldi r25,0
 1716 04d6 0E94 0000 		call delay_ms
 1717               	.LVL192:
 1718 04da 00C0      		rjmp .L89
 1719               	.L62:
 1720               	.LBE190:
 1721               	.LBE189:
2078:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 1722               		.loc 1 2078 0
 1723 04dc 62E0      		ldi r22,lo8(2)
 1724 04de 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1725 04e0 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1726 04e2 0E94 0000 		call PrintFromPROGMEMln
 1727               	.LVL193:
2079:stk500boot.c  **** 				gFlashIndex	+=	256;
 1728               		.loc 1 2079 0
 1729 04e6 4091 0000 		lds r20,gFlashIndex
 1730 04ea 5091 0000 		lds r21,gFlashIndex+1
 1731 04ee 6091 0000 		lds r22,gFlashIndex+2
 1732 04f2 7091 0000 		lds r23,gFlashIndex+3
 1733 04f6 80E0      		ldi r24,0
 1734 04f8 0E94 0000 		call DumpHex.constprop.0
 1735               	.LVL194:
2080:stk500boot.c  **** 				break;
 1736               		.loc 1 2080 0
 1737 04fc 8091 0000 		lds r24,gFlashIndex
 1738 0500 9091 0000 		lds r25,gFlashIndex+1
 1739 0504 A091 0000 		lds r26,gFlashIndex+2
 1740 0508 B091 0000 		lds r27,gFlashIndex+3
 1741 050c 9F5F      		subi r25,-1
 1742 050e AF4F      		sbci r26,-1
 1743 0510 BF4F      		sbci r27,-1
 1744 0512 8093 0000 		sts gFlashIndex,r24
 1745 0516 9093 0000 		sts gFlashIndex+1,r25
 1746 051a A093 0000 		sts gFlashIndex+2,r26
 1747 051e B093 0000 		sts gFlashIndex+3,r27
 1748 0522 00C0      		rjmp .L60
 1749               	.L72:
2084:stk500boot.c  **** 				PrintHelp();
 1750               		.loc 1 2084 0
 1751 0524 62E0      		ldi r22,lo8(2)
 1752 0526 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1753 0528 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1754 052a 0E94 0000 		call PrintFromPROGMEMln
 1755               	.LVL195:
 1756               	.LBB193:
 1757               	.LBB194:
1990:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
 1758               		.loc 1 1990 0
 1759 052e 60E0      		ldi r22,0
 1760 0530 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1761 0532 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1762 0534 0E94 0000 		call PrintFromPROGMEMln
 1763               	.LVL196:
1991:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
 1764               		.loc 1 1991 0
 1765 0538 60E0      		ldi r22,0
 1766 053a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1767 053c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1768 053e 0E94 0000 		call PrintFromPROGMEMln
 1769               	.LVL197:
1992:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
 1770               		.loc 1 1992 0
 1771 0542 60E0      		ldi r22,0
 1772 0544 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1773 0546 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1774 0548 0E94 0000 		call PrintFromPROGMEMln
 1775               	.LVL198:
1993:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
 1776               		.loc 1 1993 0
 1777 054c 60E0      		ldi r22,0
 1778 054e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1779 0550 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1780 0552 0E94 0000 		call PrintFromPROGMEMln
 1781               	.LVL199:
1994:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
 1782               		.loc 1 1994 0
 1783 0556 60E0      		ldi r22,0
 1784 0558 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1785 055a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1786 055c 0E94 0000 		call PrintFromPROGMEMln
 1787               	.LVL200:
1995:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
 1788               		.loc 1 1995 0
 1789 0560 60E0      		ldi r22,0
 1790 0562 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1791 0564 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1792 0566 0E94 0000 		call PrintFromPROGMEMln
 1793               	.LVL201:
1996:stk500boot.c  **** 
 1794               		.loc 1 1996 0
 1795 056a 60E0      		ldi r22,0
 1796 056c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1797 056e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1798 0570 0E94 0000 		call PrintFromPROGMEMln
 1799               	.LVL202:
1998:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
 1800               		.loc 1 1998 0
 1801 0574 60E0      		ldi r22,0
 1802 0576 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1803 0578 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1804 057a 0E94 0000 		call PrintFromPROGMEMln
 1805               	.LVL203:
1999:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
 1806               		.loc 1 1999 0
 1807 057e 60E0      		ldi r22,0
 1808 0580 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1809 0582 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1810 0584 0E94 0000 		call PrintFromPROGMEMln
 1811               	.LVL204:
2000:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
 1812               		.loc 1 2000 0
 1813 0588 60E0      		ldi r22,0
 1814 058a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1815 058c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1816 058e 0E94 0000 		call PrintFromPROGMEMln
 1817               	.LVL205:
2001:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
 1818               		.loc 1 2001 0
 1819 0592 60E0      		ldi r22,0
 1820 0594 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1821 0596 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1822 0598 0E94 0000 		call PrintFromPROGMEMln
 1823               	.LVL206:
2002:stk500boot.c  **** }
 1824               		.loc 1 2002 0
 1825 059c 60E0      		ldi r22,0
 1826 059e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 1827 05a0 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 1828               	.LVL207:
 1829               	.L272:
 1830               	.LBE194:
 1831               	.LBE193:
2102:stk500boot.c  **** 				break;
2103:stk500boot.c  **** 
2104:stk500boot.c  **** 			case 'V':
2105:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
2106:stk500boot.c  **** 				VectorDisplay();
2107:stk500boot.c  **** 				break;
2108:stk500boot.c  **** 
2109:stk500boot.c  **** 			case 'Y':
2110:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
2111:stk500boot.c  **** 				AVR_PortOutput();
2112:stk500boot.c  **** 				break;
2113:stk500boot.c  **** 			
2114:stk500boot.c  **** 			default:
2115:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HUH, 0);
 1832               		.loc 1 2115 0
 1833 05a2 0E94 0000 		call PrintFromPROGMEMln
 1834               	.LVL208:
 1835 05a6 00C0      		rjmp .L60
 1836               	.LVL209:
 1837               	.L70:
2094:stk500boot.c  **** 				keepGoing	=	false;
 1838               		.loc 1 2094 0
 1839 05a8 62E0      		ldi r22,lo8(2)
 1840 05aa 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1841 05ac 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1842 05ae 0E94 0000 		call PrintFromPROGMEMln
 1843               	.LVL210:
 1844               	.LBE172:
 1845               	.LBE171:
 695:stk500boot.c  **** 						isLeave			=	1;
 1846               		.loc 1 695 0
 1847 05b2 F12C      		mov r15,__zero_reg__
 1848 05b4 E12C      		mov r14,__zero_reg__
 696:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 1849               		.loc 1 696 0
 1850 05b6 F1E0      		ldi r31,lo8(1)
 1851 05b8 C25E      		subi r28,lo8(-286)
 1852 05ba DE4F      		sbci r29,hi8(-286)
 1853 05bc F883      		st Y,r31
 1854 05be CE51      		subi r28,lo8(286)
 1855 05c0 D140      		sbci r29,hi8(286)
 1856               	.LVL211:
 1857               	.L92:
 787:stk500boot.c  **** 			{
 1858               		.loc 1 787 0
 1859 05c2 2981      		ldd r18,Y+1
 1860 05c4 2331      		cpi r18,lo8(19)
 1861 05c6 01F4      		brne .+2
 1862 05c8 00C0      		rjmp .L151
 1863 05ca 00F0      		brlo .+2
 1864 05cc 00C0      		rjmp .L152
 1865 05ce 2630      		cpi r18,lo8(6)
 1866 05d0 01F4      		brne .+2
 1867 05d2 00C0      		rjmp .L153
 1868 05d4 00F0      		brlo .+2
 1869 05d6 00C0      		rjmp .L154
 1870 05d8 2230      		cpi r18,lo8(2)
 1871 05da 01F4      		brne .+2
 1872 05dc 00C0      		rjmp .L280
 1873 05de 2330      		cpi r18,lo8(3)
 1874 05e0 01F4      		brne .+2
 1875 05e2 00C0      		rjmp .L156
 1876 05e4 2130      		cpi r18,lo8(1)
 1877 05e6 01F0      		breq .+2
 1878 05e8 00C0      		rjmp .L150
 1879               	.LVL212:
 851:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 1880               		.loc 1 851 0
 1881 05ea 1A82      		std Y+2,__zero_reg__
 852:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 1882               		.loc 1 852 0
 1883 05ec 88E0      		ldi r24,lo8(8)
 1884 05ee 8B83      		std Y+3,r24
 853:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 1885               		.loc 1 853 0
 1886 05f0 81E4      		ldi r24,lo8(65)
 1887 05f2 8C83      		std Y+4,r24
 854:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 1888               		.loc 1 854 0
 1889 05f4 86E5      		ldi r24,lo8(86)
 1890 05f6 8D83      		std Y+5,r24
 855:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 1891               		.loc 1 855 0
 1892 05f8 82E5      		ldi r24,lo8(82)
 1893 05fa 8E83      		std Y+6,r24
 856:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 1894               		.loc 1 856 0
 1895 05fc 89E4      		ldi r24,lo8(73)
 1896 05fe 8F83      		std Y+7,r24
 857:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 1897               		.loc 1 857 0
 1898 0600 83E5      		ldi r24,lo8(83)
 1899 0602 8887      		std Y+8,r24
 858:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 1900               		.loc 1 858 0
 1901 0604 80E5      		ldi r24,lo8(80)
 1902 0606 8987      		std Y+9,r24
 859:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 1903               		.loc 1 859 0
 1904 0608 8FE5      		ldi r24,lo8(95)
 1905 060a 8A87      		std Y+10,r24
 860:stk500boot.c  **** 					break;
 1906               		.loc 1 860 0
 1907 060c 82E3      		ldi r24,lo8(50)
 1908 060e 8B87      		std Y+11,r24
 850:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 1909               		.loc 1 850 0
 1910 0610 0BE0      		ldi r16,lo8(11)
 1911 0612 10E0      		ldi r17,0
 861:stk500boot.c  **** 
 1912               		.loc 1 861 0
 1913 0614 00C0      		rjmp .L170
 1914               	.LVL213:
 1915               	.L74:
 1916               	.LBB231:
 1917               	.LBB229:
2105:stk500boot.c  **** 				VectorDisplay();
 1918               		.loc 1 2105 0
 1919 0616 62E0      		ldi r22,lo8(2)
 1920 0618 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1921 061a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1922 061c 0E94 0000 		call PrintFromPROGMEMln
 1923               	.LVL214:
 1924               	.LBB195:
 1925               	.LBB196:
1645:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
 1926               		.loc 1 1645 0
 1927 0620 60E0      		ldi r22,0
 1928 0622 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1929 0624 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1930 0626 0E94 0000 		call PrintFromPROGMEMln
 1931               	.LVL215:
1646:stk500boot.c  **** 	//					 V#   ADDR   op code
 1932               		.loc 1 1646 0
 1933 062a 60E0      		ldi r22,0
 1934 062c 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 1935 062e 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 1936 0630 0E94 0000 		call PrintFromPROGMEMln
 1937               	.LVL216:
1644:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1938               		.loc 1 1644 0
 1939 0634 C75D      		subi r28,lo8(-297)
 1940 0636 DE4F      		sbci r29,hi8(-297)
 1941 0638 1982      		std Y+1,__zero_reg__
 1942 063a 1882      		st Y,__zero_reg__
 1943 063c C952      		subi r28,lo8(297)
 1944 063e D140      		sbci r29,hi8(297)
1643:stk500boot.c  **** 	vectorIndex		=	0;
 1945               		.loc 1 1643 0
 1946 0640 C25E      		subi r28,lo8(-286)
 1947 0642 DE4F      		sbci r29,hi8(-286)
 1948 0644 1882      		st Y,__zero_reg__
 1949 0646 1982      		std Y+1,__zero_reg__
 1950 0648 1A82      		std Y+2,__zero_reg__
 1951 064a 1B82      		std Y+3,__zero_reg__
 1952 064c CE51      		subi r28,lo8(286)
 1953 064e D140      		sbci r29,hi8(286)
 1954               	.LVL217:
 1955               	.L96:
1651:stk500boot.c  **** 		//					 01 - 0000 = 12 34
 1956               		.loc 1 1651 0
 1957 0650 C25E      		subi r28,lo8(-286)
 1958 0652 DE4F      		sbci r29,hi8(-286)
 1959 0654 2881      		ld r18,Y
 1960 0656 3981      		ldd r19,Y+1
 1961 0658 4A81      		ldd r20,Y+2
 1962 065a 5B81      		ldd r21,Y+3
 1963 065c CE51      		subi r28,lo8(286)
 1964 065e D140      		sbci r29,hi8(286)
 1965 0660 5695      		lsr r21
 1966 0662 4795      		ror r20
 1967 0664 3795      		ror r19
 1968 0666 2795      		ror r18
 1969 0668 C35D      		subi r28,lo8(-301)
 1970 066a DE4F      		sbci r29,hi8(-301)
 1971 066c 2883      		st Y,r18
 1972 066e 3983      		std Y+1,r19
 1973 0670 4A83      		std Y+2,r20
 1974 0672 5B83      		std Y+3,r21
 1975 0674 CD52      		subi r28,lo8(301)
 1976 0676 D140      		sbci r29,hi8(301)
 1977               	.LVL218:
1653:stk500boot.c  **** 		sendchar(0x20);
 1978               		.loc 1 1653 0
 1979 0678 C75D      		subi r28,lo8(-297)
 1980 067a DE4F      		sbci r29,hi8(-297)
 1981 067c 4881      		ld r20,Y
 1982 067e 5981      		ldd r21,Y+1
 1983 0680 C952      		subi r28,lo8(297)
 1984 0682 D140      		sbci r29,hi8(297)
 1985 0684 4F5F      		subi r20,-1
 1986 0686 5F4F      		sbci r21,-1
 1987 0688 C75D      		subi r28,lo8(-297)
 1988 068a DE4F      		sbci r29,hi8(-297)
 1989 068c 5983      		std Y+1,r21
 1990 068e 4883      		st Y,r20
 1991 0690 C952      		subi r28,lo8(297)
 1992 0692 D140      		sbci r29,hi8(297)
 1993               	.LVL219:
 1994 0694 62E0      		ldi r22,lo8(2)
 1995 0696 70E0      		ldi r23,0
 1996 0698 CA01      		movw r24,r20
 1997 069a 0E94 0000 		call PrintDecInt
 1998               	.LVL220:
1654:stk500boot.c  **** 		sendchar('-');
 1999               		.loc 1 1654 0
 2000 069e 80E2      		ldi r24,lo8(32)
 2001 06a0 0E94 0000 		call sendchar
 2002               	.LVL221:
1655:stk500boot.c  **** 		sendchar(0x20);
 2003               		.loc 1 1655 0
 2004 06a4 8DE2      		ldi r24,lo8(45)
 2005 06a6 0E94 0000 		call sendchar
 2006               	.LVL222:
1656:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 2007               		.loc 1 1656 0
 2008 06aa 80E2      		ldi r24,lo8(32)
 2009 06ac 0E94 0000 		call sendchar
 2010               	.LVL223:
1657:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 2011               		.loc 1 1657 0
 2012 06b0 80E0      		ldi r24,0
 2013 06b2 0E94 0000 		call PrintHexByte
 2014               	.LVL224:
1658:stk500boot.c  **** 		sendchar(0x20);
 2015               		.loc 1 1658 0
 2016 06b6 C35D      		subi r28,lo8(-301)
 2017 06b8 DE4F      		sbci r29,hi8(-301)
 2018 06ba 8881      		ld r24,Y
 2019 06bc CD52      		subi r28,lo8(301)
 2020 06be D140      		sbci r29,hi8(301)
 2021 06c0 0E94 0000 		call PrintHexByte
 2022               	.LVL225:
1659:stk500boot.c  **** 		sendchar('=');
 2023               		.loc 1 1659 0
 2024 06c4 80E2      		ldi r24,lo8(32)
 2025 06c6 0E94 0000 		call sendchar
 2026               	.LVL226:
1660:stk500boot.c  **** 		sendchar(0x20);
 2027               		.loc 1 1660 0
 2028 06ca 8DE3      		ldi r24,lo8(61)
 2029 06cc 0E94 0000 		call sendchar
 2030               	.LVL227:
1661:stk500boot.c  **** 
 2031               		.loc 1 1661 0
 2032 06d0 80E2      		ldi r24,lo8(32)
 2033 06d2 0E94 0000 		call sendchar
 2034               	.LVL228:
 2035               	.LBB197:
1666:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2036               		.loc 1 1666 0
 2037 06d6 C25E      		subi r28,lo8(-286)
 2038 06d8 DE4F      		sbci r29,hi8(-286)
 2039 06da 8881      		ld r24,Y
 2040 06dc 9981      		ldd r25,Y+1
 2041 06de AA81      		ldd r26,Y+2
 2042 06e0 BB81      		ldd r27,Y+3
 2043 06e2 CE51      		subi r28,lo8(286)
 2044 06e4 D140      		sbci r29,hi8(286)
 2045               	/* #APP */
 2046               	 ;  1666 "stk500boot.c" 1
 2047 06e6 ABBF      		out 59, r26
 2048 06e8 FC01      		movw r30, r24
 2049 06ea 9791      		elpm r25, Z+
 2050               		
 2051               	 ;  0 "" 2
 2052               	/* #NOAPP */
 2053 06ec CB5C      		subi r28,lo8(-309)
 2054 06ee DE4F      		sbci r29,hi8(-309)
 2055 06f0 9883      		st Y,r25
 2056 06f2 C553      		subi r28,lo8(309)
 2057 06f4 D140      		sbci r29,hi8(309)
 2058               	.LVL229:
 2059               	.LBE197:
 2060 06f6 892E      		mov r8,r25
 2061 06f8 912C      		mov r9,__zero_reg__
 2062 06fa B12C      		mov r11,__zero_reg__
 2063 06fc A12C      		mov r10,__zero_reg__
 2064               	.LVL230:
 2065               	.LBB198:
 2066 06fe C25E      		subi r28,lo8(-286)
 2067 0700 DE4F      		sbci r29,hi8(-286)
 2068 0702 8881      		ld r24,Y
 2069 0704 9981      		ldd r25,Y+1
 2070 0706 AA81      		ldd r26,Y+2
 2071 0708 BB81      		ldd r27,Y+3
 2072 070a CE51      		subi r28,lo8(286)
 2073 070c D140      		sbci r29,hi8(286)
 2074 070e 0196      		adiw r24,1
 2075 0710 A11D      		adc r26,__zero_reg__
 2076 0712 B11D      		adc r27,__zero_reg__
 2077               	.LVL231:
 2078               	.LBE198:
 2079               	.LBB199:
1667:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2080               		.loc 1 1667 0
 2081               	/* #APP */
 2082               	 ;  1667 "stk500boot.c" 1
 2083 0714 ABBF      		out 59, r26
 2084 0716 FC01      		movw r30, r24
 2085 0718 8791      		elpm r24, Z+
 2086               		
 2087               	 ;  0 "" 2
 2088               	.LVL232:
 2089               	/* #NOAPP */
 2090               	.LBE199:
 2091 071a 282F      		mov r18,r24
 2092 071c 30E0      		ldi r19,0
 2093 071e 50E0      		ldi r21,0
 2094 0720 40E0      		ldi r20,0
 2095 0722 CF5C      		subi r28,lo8(-305)
 2096 0724 DE4F      		sbci r29,hi8(-305)
 2097 0726 2883      		st Y,r18
 2098 0728 3983      		std Y+1,r19
 2099 072a 4A83      		std Y+2,r20
 2100 072c 5B83      		std Y+3,r21
 2101 072e C153      		subi r28,lo8(305)
 2102 0730 D140      		sbci r29,hi8(305)
 2103               	.LVL233:
 2104               	.LBB200:
 2105 0732 C25E      		subi r28,lo8(-286)
 2106 0734 DE4F      		sbci r29,hi8(-286)
 2107 0736 4881      		ld r20,Y
 2108 0738 5981      		ldd r21,Y+1
 2109 073a 6A81      		ldd r22,Y+2
 2110 073c 7B81      		ldd r23,Y+3
 2111 073e CE51      		subi r28,lo8(286)
 2112 0740 D140      		sbci r29,hi8(286)
 2113 0742 4E5F      		subi r20,-2
 2114 0744 5F4F      		sbci r21,-1
 2115 0746 6F4F      		sbci r22,-1
 2116 0748 7F4F      		sbci r23,-1
 2117               	.LVL234:
 2118               	.LBE200:
 2119               	.LBB201:
1668:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2120               		.loc 1 1668 0
 2121               	/* #APP */
 2122               	 ;  1668 "stk500boot.c" 1
 2123 074a 6BBF      		out 59, r22
 2124 074c FA01      		movw r30, r20
 2125 074e 3791      		elpm r19, Z+
 2126               		
 2127               	 ;  0 "" 2
 2128               	/* #NOAPP */
 2129 0750 CA5C      		subi r28,lo8(-310)
 2130 0752 DE4F      		sbci r29,hi8(-310)
 2131 0754 3883      		st Y,r19
 2132 0756 C653      		subi r28,lo8(310)
 2133 0758 D140      		sbci r29,hi8(310)
 2134               	.LVL235:
 2135               	.LBE201:
 2136               	.LBB202:
1669:stk500boot.c  **** 	#else
 2137               		.loc 1 1669 0
 2138 075a C25E      		subi r28,lo8(-286)
 2139 075c DE4F      		sbci r29,hi8(-286)
 2140 075e 4881      		ld r20,Y
 2141 0760 5981      		ldd r21,Y+1
 2142 0762 6A81      		ldd r22,Y+2
 2143 0764 7B81      		ldd r23,Y+3
 2144 0766 CE51      		subi r28,lo8(286)
 2145 0768 D140      		sbci r29,hi8(286)
 2146               	.LVL236:
 2147 076a 4D5F      		subi r20,-3
 2148 076c 5F4F      		sbci r21,-1
 2149 076e 6F4F      		sbci r22,-1
 2150 0770 7F4F      		sbci r23,-1
 2151               	/* #APP */
 2152               	 ;  1669 "stk500boot.c" 1
 2153 0772 6BBF      		out 59, r22
 2154 0774 FA01      		movw r30, r20
 2155 0776 1791      		elpm r17, Z+
 2156               		
 2157               	 ;  0 "" 2
 2158               	/* #NOAPP */
 2159 0778 C25E      		subi r28,lo8(-286)
 2160 077a DE4F      		sbci r29,hi8(-286)
 2161 077c 2881      		ld r18,Y
 2162 077e 3981      		ldd r19,Y+1
 2163 0780 4A81      		ldd r20,Y+2
 2164 0782 5B81      		ldd r21,Y+3
 2165 0784 CE51      		subi r28,lo8(286)
 2166 0786 D140      		sbci r29,hi8(286)
 2167               	.LVL237:
 2168 0788 2C5F      		subi r18,-4
 2169 078a 3F4F      		sbci r19,-1
 2170 078c 4F4F      		sbci r20,-1
 2171 078e 5F4F      		sbci r21,-1
 2172 0790 C25E      		subi r28,lo8(-286)
 2173 0792 DE4F      		sbci r29,hi8(-286)
 2174 0794 2883      		st Y,r18
 2175 0796 3983      		std Y+1,r19
 2176 0798 4A83      		std Y+2,r20
 2177 079a 5B83      		std Y+3,r21
 2178 079c CE51      		subi r28,lo8(286)
 2179 079e D140      		sbci r29,hi8(286)
 2180               	.LVL238:
 2181               	.LBE202:
1676:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2182               		.loc 1 1676 0
 2183 07a0 CF5C      		subi r28,lo8(-305)
 2184 07a2 DE4F      		sbci r29,hi8(-305)
 2185 07a4 2881      		ld r18,Y
 2186 07a6 3981      		ldd r19,Y+1
 2187 07a8 4A81      		ldd r20,Y+2
 2188 07aa 5B81      		ldd r21,Y+3
 2189 07ac C153      		subi r28,lo8(305)
 2190 07ae D140      		sbci r29,hi8(305)
 2191               	.LVL239:
 2192 07b0 CC24      		clr r12
 2193 07b2 D22E      		mov r13,r18
 2194 07b4 E32E      		mov r14,r19
 2195 07b6 F42E      		mov r15,r20
 2196 07b8 C80C      		add r12,r8
 2197 07ba D91C      		adc r13,r9
 2198 07bc EA1C      		adc r14,r10
 2199 07be FB1C      		adc r15,r11
 2200               	.LVL240:
1680:stk500boot.c  **** 		sendchar(0x20);
 2201               		.loc 1 1680 0
 2202 07c0 0E94 0000 		call PrintHexByte
 2203               	.LVL241:
1681:stk500boot.c  **** 		PrintHexByte(byte1);
 2204               		.loc 1 1681 0
 2205 07c4 80E2      		ldi r24,lo8(32)
 2206 07c6 0E94 0000 		call sendchar
 2207               	.LVL242:
1682:stk500boot.c  **** 		sendchar(0x20);
 2208               		.loc 1 1682 0
 2209 07ca CB5C      		subi r28,lo8(-309)
 2210 07cc DE4F      		sbci r29,hi8(-309)
 2211 07ce 8881      		ld r24,Y
 2212 07d0 C553      		subi r28,lo8(309)
 2213 07d2 D140      		sbci r29,hi8(309)
 2214 07d4 0E94 0000 		call PrintHexByte
 2215               	.LVL243:
1683:stk500boot.c  **** 		PrintHexByte(byte4);
 2216               		.loc 1 1683 0
 2217 07d8 80E2      		ldi r24,lo8(32)
 2218 07da 0E94 0000 		call sendchar
 2219               	.LVL244:
1684:stk500boot.c  **** 		sendchar(0x20);
 2220               		.loc 1 1684 0
 2221 07de 812F      		mov r24,r17
 2222 07e0 0E94 0000 		call PrintHexByte
 2223               	.LVL245:
1685:stk500boot.c  **** 		PrintHexByte(byte3);
 2224               		.loc 1 1685 0
 2225 07e4 80E2      		ldi r24,lo8(32)
 2226 07e6 0E94 0000 		call sendchar
 2227               	.LVL246:
1686:stk500boot.c  **** 		sendchar(0x20);
 2228               		.loc 1 1686 0
 2229 07ea CA5C      		subi r28,lo8(-310)
 2230 07ec DE4F      		sbci r29,hi8(-310)
 2231 07ee 8881      		ld r24,Y
 2232 07f0 C653      		subi r28,lo8(310)
 2233 07f2 D140      		sbci r29,hi8(310)
 2234 07f4 0E94 0000 		call PrintHexByte
 2235               	.LVL247:
1687:stk500boot.c  **** 	
 2236               		.loc 1 1687 0
 2237 07f8 80E2      		ldi r24,lo8(32)
 2238 07fa 0E94 0000 		call sendchar
 2239               	.LVL248:
1689:stk500boot.c  **** 		{
 2240               		.loc 1 1689 0
 2241 07fe 3FEF      		ldi r19,-1
 2242 0800 C316      		cp r12,r19
 2243 0802 D306      		cpc r13,r19
 2244 0804 E104      		cpc r14,__zero_reg__
 2245 0806 F104      		cpc r15,__zero_reg__
 2246 0808 01F4      		brne .L93
1691:stk500boot.c  **** 		}
 2247               		.loc 1 1691 0
 2248 080a 60E0      		ldi r22,0
 2249 080c 80E0      		ldi r24,lo8(gTextMsg_noVector)
 2250 080e 90E0      		ldi r25,hi8(gTextMsg_noVector)
 2251 0810 0E94 0000 		call PrintFromPROGMEM
 2252               	.LVL249:
 2253               	.L94:
1740:stk500boot.c  **** 
 2254               		.loc 1 1740 0
 2255 0814 0E94 0000 		call PrintNewLine
 2256               	.LVL250:
1649:stk500boot.c  **** 	{
 2257               		.loc 1 1649 0
 2258 0818 C75D      		subi r28,lo8(-297)
 2259 081a DE4F      		sbci r29,hi8(-297)
 2260 081c 2881      		ld r18,Y
 2261 081e 3981      		ldd r19,Y+1
 2262 0820 C952      		subi r28,lo8(297)
 2263 0822 D140      		sbci r29,hi8(297)
 2264 0824 2933      		cpi r18,57
 2265 0826 3105      		cpc r19,__zero_reg__
 2266 0828 01F0      		breq .+2
 2267 082a 00C0      		rjmp .L96
 2268 082c 00C0      		rjmp .L60
 2269               	.LVL251:
 2270               	.L93:
1693:stk500boot.c  **** 		{
 2271               		.loc 1 1693 0
 2272 082e D701      		movw r26,r14
 2273 0830 C601      		movw r24,r12
 2274 0832 8827      		clr r24
 2275 0834 907C      		andi r25,192
 2276 0836 AA27      		clr r26
 2277 0838 BB27      		clr r27
 2278 083a 8115      		cp r24,__zero_reg__
 2279 083c 904C      		sbci r25,-64
 2280 083e A105      		cpc r26,__zero_reg__
 2281 0840 B105      		cpc r27,__zero_reg__
 2282 0842 01F4      		brne .L95
1696:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
 2283               		.loc 1 1696 0
 2284 0844 5FE3      		ldi r21,63
 2285 0846 D522      		and r13,r21
 2286 0848 EE24      		clr r14
 2287 084a FF24      		clr r15
 2288               	.LVL252:
1697:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 2289               		.loc 1 1697 0
 2290 084c C35D      		subi r28,lo8(-301)
 2291 084e DE4F      		sbci r29,hi8(-301)
 2292 0850 8880      		ld r8,Y
 2293 0852 9980      		ldd r9,Y+1
 2294 0854 AA80      		ldd r10,Y+2
 2295 0856 BB80      		ldd r11,Y+3
 2296 0858 CD52      		subi r28,lo8(301)
 2297 085a D140      		sbci r29,hi8(301)
 2298               	.LVL253:
 2299 085c 8C0C      		add r8,r12
 2300 085e 9D1C      		adc r9,r13
 2301 0860 AE1C      		adc r10,r14
 2302 0862 BF1C      		adc r11,r15
 2303               	.LVL254:
1698:stk500boot.c  **** 
 2304               		.loc 1 1698 0
 2305 0864 880C      		lsl r8
 2306 0866 991C      		rol r9
 2307 0868 AA1C      		rol r10
 2308 086a BB1C      		rol r11
 2309               	.LVL255:
1700:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
 2310               		.loc 1 1700 0
 2311 086c 60E0      		ldi r22,0
 2312 086e 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 2313 0870 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 2314 0872 0E94 0000 		call PrintFromPROGMEM
 2315               	.LVL256:
1701:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
 2316               		.loc 1 1701 0
 2317 0876 8D2D      		mov r24,r13
 2318 0878 0E94 0000 		call PrintHexByte
 2319               	.LVL257:
1702:stk500boot.c  **** 			sendchar(0x20);
 2320               		.loc 1 1702 0
 2321 087c 8C2D      		mov r24,r12
 2322 087e 0E94 0000 		call PrintHexByte
 2323               	.LVL258:
1703:stk500boot.c  **** 			sendchar('>');
 2324               		.loc 1 1703 0
 2325 0882 80E2      		ldi r24,lo8(32)
 2326 0884 0E94 0000 		call sendchar
 2327               	.LVL259:
1704:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2328               		.loc 1 1704 0
 2329 0888 8EE3      		ldi r24,lo8(62)
 2330 088a 0E94 0000 		call sendchar
 2331               	.LVL260:
1705:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2332               		.loc 1 1705 0
 2333 088e 80E0      		ldi r24,0
 2334 0890 0E94 0000 		call PrintHexByte
 2335               	.LVL261:
1706:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2336               		.loc 1 1706 0
 2337 0894 892D      		mov r24,r9
 2338 0896 0E94 0000 		call PrintHexByte
 2339               	.LVL262:
1707:stk500boot.c  **** 	
 2340               		.loc 1 1707 0
 2341 089a 882D      		mov r24,r8
 2342               	.LVL263:
 2343               	.L271:
1728:stk500boot.c  **** 		}
 2344               		.loc 1 1728 0
 2345 089c 0E94 0000 		call PrintHexByte
 2346               	.LVL264:
 2347 08a0 00C0      		rjmp .L94
 2348               	.LVL265:
 2349               	.L95:
1710:stk500boot.c  **** 		{
 2350               		.loc 1 1710 0
 2351 08a2 8EE0      		ldi r24,14
 2352 08a4 C822      		and r12,r24
 2353 08a6 E894      		clt
 2354 08a8 D0F8      		bld r13,0
 2355 08aa EE24      		clr r14
 2356 08ac FF24      		clr r15
 2357               	.LVL266:
 2358 08ae 9CE0      		ldi r25,12
 2359 08b0 C916      		cp r12,r25
 2360 08b2 94E9      		ldi r25,-108
 2361 08b4 D906      		cpc r13,r25
 2362 08b6 E104      		cpc r14,__zero_reg__
 2363 08b8 F104      		cpc r15,__zero_reg__
 2364 08ba 01F0      		breq .+2
 2365 08bc 00C0      		rjmp .L94
1713:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2366               		.loc 1 1713 0
 2367 08be B401      		movw r22,r8
 2368 08c0 5527      		clr r21
 2369 08c2 4427      		clr r20
 2370 08c4 4427      		clr r20
 2371 08c6 5527      		clr r21
 2372 08c8 6170      		andi r22,1
 2373 08ca 7727      		clr r23
1714:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
 2374               		.loc 1 1714 0
 2375 08cc E1E1      		ldi r30,17
 2376               		1:
 2377 08ce 880C      		lsl r8
 2378 08d0 991C      		rol r9
 2379 08d2 AA1C      		rol r10
 2380 08d4 BB1C      		rol r11
 2381 08d6 EA95      		dec r30
 2382 08d8 01F4      		brne 1b
 2383               	.LVL267:
 2384 08da 8824      		clr r8
 2385 08dc 9924      		clr r9
 2386 08de A0EE      		ldi r26,224
 2387 08e0 AA22      		and r10,r26
 2388 08e2 A1E0      		ldi r26,1
 2389 08e4 BA22      		and r11,r26
1713:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2390               		.loc 1 1713 0
 2391 08e6 4829      		or r20,r8
 2392 08e8 5929      		or r21,r9
 2393 08ea 6A29      		or r22,r10
 2394 08ec 7B29      		or r23,r11
1669:stk500boot.c  **** 	#else
 2395               		.loc 1 1669 0
 2396 08ee 812F      		mov r24,r17
 2397 08f0 90E0      		ldi r25,0
 2398 08f2 B0E0      		ldi r27,0
 2399 08f4 A0E0      		ldi r26,0
1677:stk500boot.c  **** 
 2400               		.loc 1 1677 0
 2401 08f6 BA2F      		mov r27,r26
 2402 08f8 A92F      		mov r26,r25
 2403 08fa 982F      		mov r25,r24
 2404 08fc 8827      		clr r24
 2405 08fe CA5C      		subi r28,lo8(-310)
 2406 0900 DE4F      		sbci r29,hi8(-310)
 2407 0902 E881      		ld r30,Y
 2408 0904 C653      		subi r28,lo8(310)
 2409 0906 D140      		sbci r29,hi8(310)
 2410 0908 8E0F      		add r24,r30
 2411 090a 911D      		adc r25,__zero_reg__
 2412 090c A11D      		adc r26,__zero_reg__
 2413 090e B11D      		adc r27,__zero_reg__
1715:stk500boot.c  **** 								word2;
 2414               		.loc 1 1715 0
 2415 0910 CF5C      		subi r28,lo8(-305)
 2416 0912 DE4F      		sbci r29,hi8(-305)
 2417 0914 8880      		ld r8,Y
 2418 0916 9980      		ldd r9,Y+1
 2419 0918 AA80      		ldd r10,Y+2
 2420 091a BB80      		ldd r11,Y+3
 2421 091c C153      		subi r28,lo8(305)
 2422 091e D140      		sbci r29,hi8(305)
 2423 0920 15E1      		ldi r17,21
 2424               		1:
 2425 0922 880C      		lsl r8
 2426 0924 991C      		rol r9
 2427 0926 AA1C      		rol r10
 2428 0928 BB1C      		rol r11
 2429 092a 1A95      		dec r17
 2430 092c 01F4      		brne 1b
 2431               	.LVL268:
 2432 092e 8824      		clr r8
 2433 0930 9924      		clr r9
 2434 0932 F0E2      		ldi r31,32
 2435 0934 AF22      		and r10,r31
 2436 0936 BB24      		clr r11
1713:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2437               		.loc 1 1713 0
 2438 0938 880D      		add r24,r8
 2439 093a 991D      		adc r25,r9
 2440 093c AA1D      		adc r26,r10
 2441 093e BB1D      		adc r27,r11
 2442 0940 4A01      		movw r8,r20
 2443 0942 5B01      		movw r10,r22
 2444 0944 880E      		add r8,r24
 2445 0946 991E      		adc r9,r25
 2446 0948 AA1E      		adc r10,r26
 2447 094a BB1E      		adc r11,r27
 2448               	.LVL269:
1718:stk500boot.c  **** 							
 2449               		.loc 1 1718 0
 2450 094c 7501      		movw r14,r10
 2451 094e 6401      		movw r12,r8
 2452 0950 CC0C      		lsl r12
 2453 0952 DD1C      		rol r13
 2454 0954 EE1C      		rol r14
 2455 0956 FF1C      		rol r15
1720:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 2456               		.loc 1 1720 0
 2457 0958 60E0      		ldi r22,0
 2458 095a 80E0      		ldi r24,lo8(gTextMsg_jmp)
 2459 095c 90E0      		ldi r25,hi8(gTextMsg_jmp)
 2460 095e 0E94 0000 		call PrintFromPROGMEM
 2461               	.LVL270:
1721:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 2462               		.loc 1 1721 0
 2463 0962 8A2D      		mov r24,r10
 2464 0964 0E94 0000 		call PrintHexByte
 2465               	.LVL271:
1722:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 2466               		.loc 1 1722 0
 2467 0968 892D      		mov r24,r9
 2468 096a 0E94 0000 		call PrintHexByte
 2469               	.LVL272:
1723:stk500boot.c  **** 			sendchar(0x20);
 2470               		.loc 1 1723 0
 2471 096e 882D      		mov r24,r8
 2472 0970 0E94 0000 		call PrintHexByte
 2473               	.LVL273:
1724:stk500boot.c  **** 			sendchar('>');
 2474               		.loc 1 1724 0
 2475 0974 80E2      		ldi r24,lo8(32)
 2476 0976 0E94 0000 		call sendchar
 2477               	.LVL274:
1725:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2478               		.loc 1 1725 0
 2479 097a 8EE3      		ldi r24,lo8(62)
 2480 097c 0E94 0000 		call sendchar
 2481               	.LVL275:
1726:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2482               		.loc 1 1726 0
 2483 0980 8E2D      		mov r24,r14
 2484 0982 0E94 0000 		call PrintHexByte
 2485               	.LVL276:
1727:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2486               		.loc 1 1727 0
 2487 0986 8D2D      		mov r24,r13
 2488 0988 0E94 0000 		call PrintHexByte
 2489               	.LVL277:
1728:stk500boot.c  **** 		}
 2490               		.loc 1 1728 0
 2491 098c 8C2D      		mov r24,r12
 2492 098e 00C0      		rjmp .L271
 2493               	.LVL278:
 2494               	.L75:
 2495               	.LBE196:
 2496               	.LBE195:
2110:stk500boot.c  **** 				AVR_PortOutput();
 2497               		.loc 1 2110 0
 2498 0990 62E0      		ldi r22,lo8(2)
 2499 0992 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2500 0994 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2501 0996 0E94 0000 		call PrintFromPROGMEMln
 2502               	.LVL279:
 2503               	.LBB203:
 2504               	.LBB204:
1814:stk500boot.c  **** 
 2505               		.loc 1 1814 0
 2506 099a 60E0      		ldi r22,0
 2507 099c 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2508 099e 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2509 09a0 0E94 0000 		call PrintFromPROGMEM
 2510               	.LVL280:
1816:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2511               		.loc 1 1816 0
 2512 09a4 0E94 0000 		call recchar
 2513               	.LVL281:
1817:stk500boot.c  **** 	sendchar(portLetter);
 2514               		.loc 1 1817 0
 2515 09a8 182F      		mov r17,r24
 2516               	.LVL282:
 2517 09aa 1F75      		andi r17,lo8(95)
 2518               	.LVL283:
1818:stk500boot.c  **** 	PrintNewLine();
 2519               		.loc 1 1818 0
 2520 09ac 812F      		mov r24,r17
 2521 09ae 0E94 0000 		call sendchar
 2522               	.LVL284:
1819:stk500boot.c  **** 
 2523               		.loc 1 1819 0
 2524 09b2 0E94 0000 		call PrintNewLine
 2525               	.LVL285:
1821:stk500boot.c  **** 	{
 2526               		.loc 1 1821 0
 2527 09b6 8FEB      		ldi r24,lo8(-65)
 2528 09b8 810F      		add r24,r17
 2529 09ba 8A31      		cpi r24,lo8(26)
 2530 09bc 00F0      		brlo .+2
 2531 09be 00C0      		rjmp .L98
 2532               	.LVL286:
1824:stk500boot.c  **** 		{
 2533               		.loc 1 1824 0
 2534 09c0 1634      		cpi r17,lo8(70)
 2535 09c2 01F4      		brne .+2
 2536 09c4 00C0      		rjmp .L100
 2537 09c6 00F4      		brsh .L101
 2538 09c8 1334      		cpi r17,lo8(67)
 2539 09ca 01F4      		brne .+2
 2540 09cc 00C0      		rjmp .L102
 2541 09ce 00F4      		brsh .L103
 2542 09d0 1134      		cpi r17,lo8(65)
 2543 09d2 01F0      		breq .L104
 2544 09d4 1234      		cpi r17,lo8(66)
 2545 09d6 01F4      		brne .+2
 2546 09d8 00C0      		rjmp .L105
 2547               	.L99:
1971:stk500boot.c  **** 				getCharFlag	=	false;
 2548               		.loc 1 1971 0
 2549 09da 60E0      		ldi r22,0
 2550 09dc 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2551 09de 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2552 09e0 00C0      		rjmp .L272
 2553               	.L103:
1824:stk500boot.c  **** 		{
 2554               		.loc 1 1824 0
 2555 09e2 1434      		cpi r17,lo8(68)
 2556 09e4 01F4      		brne .+2
 2557 09e6 00C0      		rjmp .L106
 2558 09e8 1534      		cpi r17,lo8(69)
 2559 09ea 01F4      		brne .L99
1876:stk500boot.c  **** 				while (!Serial_Available())
 2560               		.loc 1 1876 0
 2561 09ec 0DB9      		out 0xd,r16
 2562               	.L123:
 2563               	.LBB205:
 2564               	.LBB206:
 477:stk500boot.c  **** }
 2565               		.loc 1 477 0
 2566 09ee 8091 C800 		lds r24,200
 2567               	.LBE206:
 2568               	.LBE205:
1877:stk500boot.c  **** 				{
 2569               		.loc 1 1877 0
 2570 09f2 87FF      		sbrs r24,7
 2571 09f4 00C0      		rjmp .L124
1882:stk500boot.c  **** 				break;
 2572               		.loc 1 1882 0
 2573 09f6 1EB8      		out 0xe,__zero_reg__
 2574 09f8 00C0      		rjmp .L116
 2575               	.L101:
1824:stk500boot.c  **** 		{
 2576               		.loc 1 1824 0
 2577 09fa 1A34      		cpi r17,lo8(74)
 2578 09fc 01F4      		brne .+2
 2579 09fe 00C0      		rjmp .L108
 2580 0a00 00F4      		brsh .L109
 2581 0a02 1734      		cpi r17,lo8(71)
 2582 0a04 01F4      		brne .+2
 2583 0a06 00C0      		rjmp .L110
 2584 0a08 1834      		cpi r17,lo8(72)
 2585 0a0a 01F4      		brne .L99
1912:stk500boot.c  **** 				while (!Serial_Available())
 2586               		.loc 1 1912 0
 2587 0a0c 0093 0101 		sts 257,r16
 2588               	.L129:
 2589               	.LBB207:
 2590               	.LBB208:
 477:stk500boot.c  **** }
 2591               		.loc 1 477 0
 2592 0a10 8091 C800 		lds r24,200
 2593               	.LBE208:
 2594               	.LBE207:
1913:stk500boot.c  **** 				{
 2595               		.loc 1 1913 0
 2596 0a14 87FF      		sbrs r24,7
 2597 0a16 00C0      		rjmp .L130
1918:stk500boot.c  **** 				break;
 2598               		.loc 1 1918 0
 2599 0a18 1092 0201 		sts 258,__zero_reg__
 2600 0a1c 00C0      		rjmp .L116
 2601               	.L109:
1824:stk500boot.c  **** 		{
 2602               		.loc 1 1824 0
 2603 0a1e 1B34      		cpi r17,lo8(75)
 2604 0a20 01F4      		brne .+2
 2605 0a22 00C0      		rjmp .L112
 2606 0a24 1C34      		cpi r17,lo8(76)
 2607 0a26 01F4      		brne .L99
1960:stk500boot.c  **** 				while (!Serial_Available())
 2608               		.loc 1 1960 0
 2609 0a28 0093 0A01 		sts 266,r16
 2610               	.L135:
 2611               	.LBB209:
 2612               	.LBB210:
 477:stk500boot.c  **** }
 2613               		.loc 1 477 0
 2614 0a2c 8091 C800 		lds r24,200
 2615               	.LBE210:
 2616               	.LBE209:
1961:stk500boot.c  **** 				{
 2617               		.loc 1 1961 0
 2618 0a30 87FF      		sbrs r24,7
 2619 0a32 00C0      		rjmp .L136
1966:stk500boot.c  **** 				break;
 2620               		.loc 1 1966 0
 2621 0a34 1092 0B01 		sts 267,__zero_reg__
 2622 0a38 00C0      		rjmp .L116
 2623               	.L104:
1828:stk500boot.c  **** 				while (!Serial_Available())
 2624               		.loc 1 1828 0
 2625 0a3a 01B9      		out 0x1,r16
 2626               	.L114:
 2627               	.LBB211:
 2628               	.LBB212:
 477:stk500boot.c  **** }
 2629               		.loc 1 477 0
 2630 0a3c 8091 C800 		lds r24,200
 2631               	.LBE212:
 2632               	.LBE211:
1829:stk500boot.c  **** 				{
 2633               		.loc 1 1829 0
 2634 0a40 87FF      		sbrs r24,7
 2635 0a42 00C0      		rjmp .L115
1834:stk500boot.c  **** 				break;
 2636               		.loc 1 1834 0
 2637 0a44 12B8      		out 0x2,__zero_reg__
 2638 0a46 00C0      		rjmp .L116
 2639               	.L115:
1831:stk500boot.c  **** 					delay_ms(200);
 2640               		.loc 1 1831 0
 2641 0a48 82B1      		in r24,0x2
 2642 0a4a 8095      		com r24
 2643 0a4c 82B9      		out 0x2,r24
1832:stk500boot.c  **** 				}
 2644               		.loc 1 1832 0
 2645 0a4e 88EC      		ldi r24,lo8(-56)
 2646 0a50 90E0      		ldi r25,0
 2647 0a52 0E94 0000 		call delay_ms
 2648               	.LVL287:
 2649 0a56 00C0      		rjmp .L114
 2650               	.L105:
1840:stk500boot.c  **** 				while (!Serial_Available())
 2651               		.loc 1 1840 0
 2652 0a58 04B9      		out 0x4,r16
 2653               	.L117:
 2654               	.LBB213:
 2655               	.LBB214:
 477:stk500boot.c  **** }
 2656               		.loc 1 477 0
 2657 0a5a 8091 C800 		lds r24,200
 2658               	.LBE214:
 2659               	.LBE213:
1841:stk500boot.c  **** 				{
 2660               		.loc 1 1841 0
 2661 0a5e 87FF      		sbrs r24,7
 2662 0a60 00C0      		rjmp .L118
1846:stk500boot.c  **** 				break;
 2663               		.loc 1 1846 0
 2664 0a62 15B8      		out 0x5,__zero_reg__
 2665 0a64 00C0      		rjmp .L116
 2666               	.L118:
1843:stk500boot.c  **** 					delay_ms(200);
 2667               		.loc 1 1843 0
 2668 0a66 85B1      		in r24,0x5
 2669 0a68 8095      		com r24
 2670 0a6a 85B9      		out 0x5,r24
1844:stk500boot.c  **** 				}
 2671               		.loc 1 1844 0
 2672 0a6c 88EC      		ldi r24,lo8(-56)
 2673 0a6e 90E0      		ldi r25,0
 2674 0a70 0E94 0000 		call delay_ms
 2675               	.LVL288:
 2676 0a74 00C0      		rjmp .L117
 2677               	.L102:
1852:stk500boot.c  **** 				while (!Serial_Available())
 2678               		.loc 1 1852 0
 2679 0a76 07B9      		out 0x7,r16
 2680               	.L119:
 2681               	.LBB215:
 2682               	.LBB216:
 477:stk500boot.c  **** }
 2683               		.loc 1 477 0
 2684 0a78 8091 C800 		lds r24,200
 2685               	.LBE216:
 2686               	.LBE215:
1853:stk500boot.c  **** 				{
 2687               		.loc 1 1853 0
 2688 0a7c 87FF      		sbrs r24,7
 2689 0a7e 00C0      		rjmp .L120
1858:stk500boot.c  **** 				break;
 2690               		.loc 1 1858 0
 2691 0a80 18B8      		out 0x8,__zero_reg__
 2692 0a82 00C0      		rjmp .L116
 2693               	.L120:
1855:stk500boot.c  **** 					delay_ms(200);
 2694               		.loc 1 1855 0
 2695 0a84 88B1      		in r24,0x8
 2696 0a86 8095      		com r24
 2697 0a88 88B9      		out 0x8,r24
1856:stk500boot.c  **** 				}
 2698               		.loc 1 1856 0
 2699 0a8a 88EC      		ldi r24,lo8(-56)
 2700 0a8c 90E0      		ldi r25,0
 2701 0a8e 0E94 0000 		call delay_ms
 2702               	.LVL289:
 2703 0a92 00C0      		rjmp .L119
 2704               	.L106:
1864:stk500boot.c  **** 				while (!Serial_Available())
 2705               		.loc 1 1864 0
 2706 0a94 0AB9      		out 0xa,r16
 2707               	.L121:
 2708               	.LBB217:
 2709               	.LBB218:
 477:stk500boot.c  **** }
 2710               		.loc 1 477 0
 2711 0a96 8091 C800 		lds r24,200
 2712               	.LBE218:
 2713               	.LBE217:
1865:stk500boot.c  **** 				{
 2714               		.loc 1 1865 0
 2715 0a9a 87FF      		sbrs r24,7
 2716 0a9c 00C0      		rjmp .L122
1870:stk500boot.c  **** 				break;
 2717               		.loc 1 1870 0
 2718 0a9e 1BB8      		out 0xb,__zero_reg__
 2719 0aa0 00C0      		rjmp .L116
 2720               	.L122:
1867:stk500boot.c  **** 					delay_ms(200);
 2721               		.loc 1 1867 0
 2722 0aa2 8BB1      		in r24,0xb
 2723 0aa4 8095      		com r24
 2724 0aa6 8BB9      		out 0xb,r24
1868:stk500boot.c  **** 				}
 2725               		.loc 1 1868 0
 2726 0aa8 88EC      		ldi r24,lo8(-56)
 2727 0aaa 90E0      		ldi r25,0
 2728 0aac 0E94 0000 		call delay_ms
 2729               	.LVL290:
 2730 0ab0 00C0      		rjmp .L121
 2731               	.L124:
1879:stk500boot.c  **** 					delay_ms(200);
 2732               		.loc 1 1879 0
 2733 0ab2 8EB1      		in r24,0xe
 2734 0ab4 8095      		com r24
 2735 0ab6 8EB9      		out 0xe,r24
1880:stk500boot.c  **** 				}
 2736               		.loc 1 1880 0
 2737 0ab8 88EC      		ldi r24,lo8(-56)
 2738 0aba 90E0      		ldi r25,0
 2739 0abc 0E94 0000 		call delay_ms
 2740               	.LVL291:
 2741 0ac0 00C0      		rjmp .L123
 2742               	.L100:
1888:stk500boot.c  **** 				while (!Serial_Available())
 2743               		.loc 1 1888 0
 2744 0ac2 00BB      		out 0x10,r16
 2745               	.L125:
 2746               	.LBB219:
 2747               	.LBB220:
 477:stk500boot.c  **** }
 2748               		.loc 1 477 0
 2749 0ac4 8091 C800 		lds r24,200
 2750               	.LBE220:
 2751               	.LBE219:
1889:stk500boot.c  **** 				{
 2752               		.loc 1 1889 0
 2753 0ac8 87FF      		sbrs r24,7
 2754 0aca 00C0      		rjmp .L126
1894:stk500boot.c  **** 				break;
 2755               		.loc 1 1894 0
 2756 0acc 11BA      		out 0x11,__zero_reg__
 2757 0ace 00C0      		rjmp .L116
 2758               	.L126:
1891:stk500boot.c  **** 					delay_ms(200);
 2759               		.loc 1 1891 0
 2760 0ad0 81B3      		in r24,0x11
 2761 0ad2 8095      		com r24
 2762 0ad4 81BB      		out 0x11,r24
1892:stk500boot.c  **** 				}
 2763               		.loc 1 1892 0
 2764 0ad6 88EC      		ldi r24,lo8(-56)
 2765 0ad8 90E0      		ldi r25,0
 2766 0ada 0E94 0000 		call delay_ms
 2767               	.LVL292:
 2768 0ade 00C0      		rjmp .L125
 2769               	.L110:
1900:stk500boot.c  **** 				while (!Serial_Available())
 2770               		.loc 1 1900 0
 2771 0ae0 03BB      		out 0x13,r16
 2772               	.L127:
 2773               	.LBB221:
 2774               	.LBB222:
 477:stk500boot.c  **** }
 2775               		.loc 1 477 0
 2776 0ae2 8091 C800 		lds r24,200
 2777               	.LBE222:
 2778               	.LBE221:
1901:stk500boot.c  **** 				{
 2779               		.loc 1 1901 0
 2780 0ae6 87FF      		sbrs r24,7
 2781 0ae8 00C0      		rjmp .L128
1906:stk500boot.c  **** 				break;
 2782               		.loc 1 1906 0
 2783 0aea 14BA      		out 0x14,__zero_reg__
 2784 0aec 00C0      		rjmp .L116
 2785               	.L128:
1903:stk500boot.c  **** 					delay_ms(200);
 2786               		.loc 1 1903 0
 2787 0aee 84B3      		in r24,0x14
 2788 0af0 8095      		com r24
 2789 0af2 84BB      		out 0x14,r24
1904:stk500boot.c  **** 				}
 2790               		.loc 1 1904 0
 2791 0af4 88EC      		ldi r24,lo8(-56)
 2792 0af6 90E0      		ldi r25,0
 2793 0af8 0E94 0000 		call delay_ms
 2794               	.LVL293:
 2795 0afc 00C0      		rjmp .L127
 2796               	.L130:
1915:stk500boot.c  **** 					delay_ms(200);
 2797               		.loc 1 1915 0
 2798 0afe 8091 0201 		lds r24,258
 2799 0b02 8095      		com r24
 2800 0b04 8093 0201 		sts 258,r24
1916:stk500boot.c  **** 				}
 2801               		.loc 1 1916 0
 2802 0b08 88EC      		ldi r24,lo8(-56)
 2803 0b0a 90E0      		ldi r25,0
 2804 0b0c 0E94 0000 		call delay_ms
 2805               	.LVL294:
 2806 0b10 00C0      		rjmp .L129
 2807               	.L108:
1936:stk500boot.c  **** 				while (!Serial_Available())
 2808               		.loc 1 1936 0
 2809 0b12 0093 0401 		sts 260,r16
 2810               	.L131:
 2811               	.LBB223:
 2812               	.LBB224:
 477:stk500boot.c  **** }
 2813               		.loc 1 477 0
 2814 0b16 8091 C800 		lds r24,200
 2815               	.LBE224:
 2816               	.LBE223:
1937:stk500boot.c  **** 				{
 2817               		.loc 1 1937 0
 2818 0b1a 87FF      		sbrs r24,7
 2819 0b1c 00C0      		rjmp .L132
1942:stk500boot.c  **** 				break;
 2820               		.loc 1 1942 0
 2821 0b1e 1092 0501 		sts 261,__zero_reg__
 2822 0b22 00C0      		rjmp .L116
 2823               	.L132:
1939:stk500boot.c  **** 					delay_ms(200);
 2824               		.loc 1 1939 0
 2825 0b24 8091 0501 		lds r24,261
 2826 0b28 8095      		com r24
 2827 0b2a 8093 0501 		sts 261,r24
1940:stk500boot.c  **** 				}
 2828               		.loc 1 1940 0
 2829 0b2e 88EC      		ldi r24,lo8(-56)
 2830 0b30 90E0      		ldi r25,0
 2831 0b32 0E94 0000 		call delay_ms
 2832               	.LVL295:
 2833 0b36 00C0      		rjmp .L131
 2834               	.L112:
1948:stk500boot.c  **** 				while (!Serial_Available())
 2835               		.loc 1 1948 0
 2836 0b38 0093 0701 		sts 263,r16
 2837               	.L133:
 2838               	.LBB225:
 2839               	.LBB226:
 477:stk500boot.c  **** }
 2840               		.loc 1 477 0
 2841 0b3c 8091 C800 		lds r24,200
 2842               	.LBE226:
 2843               	.LBE225:
1949:stk500boot.c  **** 				{
 2844               		.loc 1 1949 0
 2845 0b40 87FF      		sbrs r24,7
 2846 0b42 00C0      		rjmp .L134
1954:stk500boot.c  **** 				break;
 2847               		.loc 1 1954 0
 2848 0b44 1092 0801 		sts 264,__zero_reg__
 2849 0b48 00C0      		rjmp .L116
 2850               	.L134:
1951:stk500boot.c  **** 					delay_ms(200);
 2851               		.loc 1 1951 0
 2852 0b4a 8091 0801 		lds r24,264
 2853 0b4e 8095      		com r24
 2854 0b50 8093 0801 		sts 264,r24
1952:stk500boot.c  **** 				}
 2855               		.loc 1 1952 0
 2856 0b54 88EC      		ldi r24,lo8(-56)
 2857 0b56 90E0      		ldi r25,0
 2858 0b58 0E94 0000 		call delay_ms
 2859               	.LVL296:
 2860 0b5c 00C0      		rjmp .L133
 2861               	.L136:
1963:stk500boot.c  **** 					delay_ms(200);
 2862               		.loc 1 1963 0
 2863 0b5e 8091 0B01 		lds r24,267
 2864 0b62 8095      		com r24
 2865 0b64 8093 0B01 		sts 267,r24
1964:stk500boot.c  **** 				}
 2866               		.loc 1 1964 0
 2867 0b68 88EC      		ldi r24,lo8(-56)
 2868 0b6a 90E0      		ldi r25,0
 2869 0b6c 0E94 0000 		call delay_ms
 2870               	.LVL297:
 2871 0b70 00C0      		rjmp .L135
 2872               	.LVL298:
 2873               	.L98:
1982:stk500boot.c  **** 	}
 2874               		.loc 1 1982 0
 2875 0b72 60E0      		ldi r22,0
 2876 0b74 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 2877 0b76 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 2878 0b78 00C0      		rjmp .L272
 2879               	.LVL299:
 2880               	.L55:
 2881               	.LBE204:
 2882               	.LBE203:
 2883               	.LBE229:
 2884               	.LBE231:
 707:stk500boot.c  **** 				{
 2885               		.loc 1 707 0
 2886 0b7a 8330      		cpi r24,lo8(3)
 2887 0b7c 01F4      		brne .+2
 2888 0b7e 00C0      		rjmp .L201
 2889 0b80 00F4      		brsh .L141
 2890 0b82 8130      		cpi r24,lo8(1)
 2891 0b84 01F4      		brne .+2
 2892 0b86 00C0      		rjmp .L199
 2893 0b88 00F0      		brlo .L267
 703:stk500boot.c  **** 				}
 2894               		.loc 1 703 0
 2895 0b8a F12C      		mov r15,__zero_reg__
 2896 0b8c E12C      		mov r14,__zero_reg__
 2897               	.LVL300:
 2898               	.L143:
 737:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 2899               		.loc 1 737 0
 2900 0b8e 292F      		mov r18,r25
 2901               	.LVL301:
 2902 0b90 30E0      		ldi r19,0
 2903 0b92 322F      		mov r19,r18
 2904 0b94 2227      		clr r18
 2905               	.LVL302:
 739:stk500boot.c  **** 						break;
 2906               		.loc 1 739 0
 2907 0b96 B926      		eor r11,r25
 2908               	.LVL303:
 738:stk500boot.c  **** 						checksum		^=	c;
 2909               		.loc 1 738 0
 2910 0b98 83E0      		ldi r24,lo8(3)
 740:stk500boot.c  **** 
 2911               		.loc 1 740 0
 2912 0b9a 00C0      		rjmp .L149
 2913               	.LVL304:
 2914               	.L141:
 707:stk500boot.c  **** 				{
 2915               		.loc 1 707 0
 2916 0b9c 8530      		cpi r24,lo8(5)
 2917 0b9e 01F4      		brne .+2
 2918 0ba0 00C0      		rjmp .L203
 2919 0ba2 00F4      		brsh .+2
 2920 0ba4 00C0      		rjmp .L202
 703:stk500boot.c  **** 				}
 2921               		.loc 1 703 0
 2922 0ba6 F12C      		mov r15,__zero_reg__
 2923 0ba8 E12C      		mov r14,__zero_reg__
 707:stk500boot.c  **** 				{
 2924               		.loc 1 707 0
 2925 0baa 8630      		cpi r24,lo8(6)
 2926 0bac 01F4      		brne .+2
 2927 0bae 00C0      		rjmp .L147
 703:stk500boot.c  **** 				}
 2928               		.loc 1 703 0
 2929 0bb0 F12C      		mov r15,__zero_reg__
 2930 0bb2 E12C      		mov r14,__zero_reg__
 2931               	.LVL305:
 2932               	.L139:
 672:stk500boot.c  **** 			{
 2933               		.loc 1 672 0
 2934 0bb4 8730      		cpi r24,lo8(7)
 2935 0bb6 01F4      		brne .L149
 2936               	.LVL306:
 2937               	.L208:
 2938 0bb8 C25E      		subi r28,lo8(-286)
 2939 0bba DE4F      		sbci r29,hi8(-286)
 2940 0bbc 1882      		st Y,__zero_reg__
 2941 0bbe CE51      		subi r28,lo8(286)
 2942 0bc0 D140      		sbci r29,hi8(286)
 2943 0bc2 00C0      		rjmp .L92
 2944               	.LVL307:
 2945               	.L267:
 703:stk500boot.c  **** 				}
 2946               		.loc 1 703 0
 2947 0bc4 F12C      		mov r15,__zero_reg__
 2948 0bc6 E12C      		mov r14,__zero_reg__
 710:stk500boot.c  **** 						{
 2949               		.loc 1 710 0
 2950 0bc8 9B31      		cpi r25,lo8(27)
 2951 0bca 01F4      		brne .+2
 2952 0bcc 00C0      		rjmp .L205
 2953               	.LVL308:
 2954               	.L149:
 581:stk500boot.c  **** 	boot_state	=	0;
 2955               		.loc 1 581 0
 2956 0bce 50E0      		ldi r21,0
 2957 0bd0 40E0      		ldi r20,0
 2958               	.LVL309:
 2959               	.L193:
 674:stk500boot.c  **** 				{
 2960               		.loc 1 674 0
 2961 0bd2 4130      		cpi r20,1
 2962 0bd4 5105      		cpc r21,__zero_reg__
 2963 0bd6 01F0      		breq .+2
 2964 0bd8 00C0      		rjmp .L53
 2965               	.LVL310:
 2966               	.L270:
 2967               	.LBB232:
 2968               	.LBB169:
 523:stk500boot.c  **** }
 2969               		.loc 1 523 0
 2970 0bda 9091 CE00 		lds r25,206
 2971               	.LVL311:
 2972               	.LBE169:
 2973               	.LBE232:
 687:stk500boot.c  **** 
 2974               		.loc 1 687 0
 2975 0bde C55D      		subi r28,lo8(-299)
 2976 0be0 DE4F      		sbci r29,hi8(-299)
 2977 0be2 A881      		ld r26,Y
 2978 0be4 B981      		ldd r27,Y+1
 2979 0be6 CB52      		subi r28,lo8(299)
 2980 0be8 D140      		sbci r29,hi8(299)
 2981 0bea 1196      		adiw r26,1
 2982 0bec C55D      		subi r28,lo8(-299)
 2983 0bee DE4F      		sbci r29,hi8(-299)
 2984 0bf0 B983      		std Y+1,r27
 2985 0bf2 A883      		st Y,r26
 2986 0bf4 CB52      		subi r28,lo8(299)
 2987 0bf6 D140      		sbci r29,hi8(299)
 2988               	.LVL312:
 689:stk500boot.c  **** 				{
 2989               		.loc 1 689 0
 2990 0bf8 9132      		cpi r25,lo8(33)
 2991 0bfa 01F0      		breq .+2
 2992 0bfc 00C0      		rjmp .L55
 689:stk500boot.c  **** 				{
 2993               		.loc 1 689 0 is_stmt 0 discriminator 1
 2994 0bfe 1A97      		sbiw r26,10
 2995 0c00 00F0      		brlo .+2
 2996 0c02 00C0      		rjmp .L196
 691:stk500boot.c  **** 					if (exPointCntr == 3)
 2997               		.loc 1 691 0 is_stmt 1
 2998 0c04 BFEF      		ldi r27,-1
 2999 0c06 EB1A      		sub r14,r27
 3000 0c08 FB0A      		sbc r15,r27
 3001               	.LVL313:
 692:stk500boot.c  **** 					{
 3002               		.loc 1 692 0
 3003 0c0a E3E0      		ldi r30,3
 3004 0c0c EE16      		cp r14,r30
 3005 0c0e F104      		cpc r15,__zero_reg__
 3006 0c10 01F0      		breq .+2
 3007 0c12 00C0      		rjmp .L56
 3008 0c14 E5E0      		ldi r30,lo8(5)
 3009 0c16 EE2E      		mov r14,r30
 3010 0c18 F12C      		mov r15,__zero_reg__
 3011               	.LVL314:
 3012               	.L57:
 581:stk500boot.c  **** 	boot_state	=	0;
 3013               		.loc 1 581 0
 3014 0c1a 09E1      		ldi r16,lo8(25)
 3015 0c1c 10E0      		ldi r17,0
 3016               	.LVL315:
 3017               	.L58:
 3018               	.LBB233:
 3019               	.LBB230:
2016:stk500boot.c  **** 		}
 3020               		.loc 1 2016 0
 3021 0c1e 81E2      		ldi r24,lo8(33)
 3022 0c20 0E94 0000 		call sendchar
 3023               	.LVL316:
 3024 0c24 0150      		subi r16,1
 3025 0c26 1109      		sbc r17,__zero_reg__
 3026               	.LVL317:
2014:stk500boot.c  **** 		{
 3027               		.loc 1 2014 0
 3028 0c28 01F4      		brne .L58
2018:stk500boot.c  **** 	}
 3029               		.loc 1 2018 0
 3030 0c2a 0E94 0000 		call PrintNewLine
 3031               	.LVL318:
 3032 0c2e F1E0      		ldi r31,1
 3033 0c30 EF1A      		sub r14,r31
 3034 0c32 F108      		sbc r15,__zero_reg__
 3035               	.LVL319:
2012:stk500boot.c  **** 	{
 3036               		.loc 1 2012 0
 3037 0c34 01F4      		brne .L57
2021:stk500boot.c  **** 	gFlashIndex			=	0;
 3038               		.loc 1 2021 0
 3039 0c36 1092 0000 		sts gRamIndex,__zero_reg__
 3040 0c3a 1092 0000 		sts gRamIndex+1,__zero_reg__
 3041 0c3e 1092 0000 		sts gRamIndex+2,__zero_reg__
 3042 0c42 1092 0000 		sts gRamIndex+3,__zero_reg__
2022:stk500boot.c  **** 	gEepromIndex		=	0;
 3043               		.loc 1 2022 0
 3044 0c46 1092 0000 		sts gFlashIndex,__zero_reg__
 3045 0c4a 1092 0000 		sts gFlashIndex+1,__zero_reg__
 3046 0c4e 1092 0000 		sts gFlashIndex+2,__zero_reg__
 3047 0c52 1092 0000 		sts gFlashIndex+3,__zero_reg__
2023:stk500boot.c  **** 
 3048               		.loc 1 2023 0
 3049 0c56 1092 0000 		sts gEepromIndex,__zero_reg__
 3050 0c5a 1092 0000 		sts gEepromIndex+1,__zero_reg__
 3051 0c5e 1092 0000 		sts gEepromIndex+2,__zero_reg__
 3052 0c62 1092 0000 		sts gEepromIndex+3,__zero_reg__
2025:stk500boot.c  **** 
 3053               		.loc 1 2025 0
 3054 0c66 60E0      		ldi r22,0
 3055 0c68 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 3056 0c6a 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 3057 0c6c 0E94 0000 		call PrintFromPROGMEMln
 3058               	.LVL320:
 3059               	.LBB228:
 3060               	.LBB227:
1888:stk500boot.c  **** 				while (!Serial_Available())
 3061               		.loc 1 1888 0
 3062 0c70 0FEF      		ldi r16,lo8(-1)
 3063               	.LVL321:
 3064               	.L60:
 3065               	.LBE227:
 3066               	.LBE228:
2030:stk500boot.c  **** 		theChar	=	recchar();
 3067               		.loc 1 2030 0
 3068 0c72 60E0      		ldi r22,0
 3069 0c74 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 3070 0c76 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 3071 0c78 0E94 0000 		call PrintFromPROGMEM
 3072               	.LVL322:
2031:stk500boot.c  **** 		if (theChar >= 0x60)
 3073               		.loc 1 2031 0
 3074 0c7c 0E94 0000 		call recchar
 3075               	.LVL323:
 3076 0c80 182F      		mov r17,r24
 3077               	.LVL324:
2032:stk500boot.c  **** 		{
 3078               		.loc 1 2032 0
 3079 0c82 8036      		cpi r24,lo8(96)
 3080 0c84 00F0      		brlo .L138
2034:stk500boot.c  **** 		}
 3081               		.loc 1 2034 0
 3082 0c86 1F75      		andi r17,lo8(95)
 3083               	.LVL325:
 3084               	.L138:
2037:stk500boot.c  **** 		{
 3085               		.loc 1 2037 0
 3086 0c88 1032      		cpi r17,lo8(32)
 3087 0c8a 00F0      		brlo .L61
2039:stk500boot.c  **** 			sendchar(0x20);
 3088               		.loc 1 2039 0
 3089 0c8c 812F      		mov r24,r17
 3090 0c8e 0E94 0000 		call sendchar
 3091               	.LVL326:
2040:stk500boot.c  **** 		}
 3092               		.loc 1 2040 0
 3093 0c92 80E2      		ldi r24,lo8(32)
 3094 0c94 0E94 0000 		call sendchar
 3095               	.LVL327:
2043:stk500boot.c  **** 		{
 3096               		.loc 1 2043 0
 3097 0c98 1634      		cpi r17,lo8(70)
 3098 0c9a 01F4      		brne .+2
 3099 0c9c 00C0      		rjmp .L62
 3100 0c9e 00F0      		brlo .+2
 3101 0ca0 00C0      		rjmp .L63
 3102 0ca2 1034      		cpi r17,lo8(64)
 3103 0ca4 01F4      		brne .+2
 3104 0ca6 00C0      		rjmp .L64
 3105 0ca8 00F0      		brlo .+2
 3106 0caa 00C0      		rjmp .L65
 3107 0cac 1033      		cpi r17,lo8(48)
 3108 0cae 01F4      		brne .+2
 3109 0cb0 00C0      		rjmp .L66
 3110 0cb2 1F33      		cpi r17,lo8(63)
 3111 0cb4 01F4      		brne .+2
 3112 0cb6 00C0      		rjmp .L67
 3113               	.L61:
 3114               		.loc 1 2115 0
 3115 0cb8 60E0      		ldi r22,0
 3116 0cba 80E0      		ldi r24,lo8(gTextMsg_HUH)
 3117 0cbc 90E0      		ldi r25,hi8(gTextMsg_HUH)
 3118 0cbe 00C0      		rjmp .L272
 3119               	.LVL328:
 3120               	.L199:
 3121               	.LBE230:
 3122               	.LBE233:
 703:stk500boot.c  **** 				}
 3123               		.loc 1 703 0
 3124 0cc0 F12C      		mov r15,__zero_reg__
 3125 0cc2 E12C      		mov r14,__zero_reg__
 3126               	.LVL329:
 3127               	.L142:
 721:stk500boot.c  **** 					#else
 3128               		.loc 1 721 0
 3129 0cc4 B926      		eor r11,r25
 3130               	.LVL330:
 734:stk500boot.c  **** 
 3131               		.loc 1 734 0
 3132 0cc6 C85D      		subi r28,lo8(-296)
 3133 0cc8 DE4F      		sbci r29,hi8(-296)
 3134 0cca 9883      		st Y,r25
 3135 0ccc C852      		subi r28,lo8(296)
 3136 0cce D140      		sbci r29,hi8(296)
 720:stk500boot.c  **** 						checksum		^=	c;
 3137               		.loc 1 720 0
 3138 0cd0 82E0      		ldi r24,lo8(2)
 734:stk500boot.c  **** 
 3139               		.loc 1 734 0
 3140 0cd2 00C0      		rjmp .L149
 3141               	.LVL331:
 3142               	.L201:
 703:stk500boot.c  **** 				}
 3143               		.loc 1 703 0
 3144 0cd4 F12C      		mov r15,__zero_reg__
 3145 0cd6 E12C      		mov r14,__zero_reg__
 3146               	.LVL332:
 3147               	.L140:
 743:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 3148               		.loc 1 743 0
 3149 0cd8 292B      		or r18,r25
 3150               	.LVL333:
 745:stk500boot.c  **** 						break;
 3151               		.loc 1 745 0
 3152 0cda B926      		eor r11,r25
 3153               	.LVL334:
 744:stk500boot.c  **** 						checksum		^=	c;
 3154               		.loc 1 744 0
 3155 0cdc 84E0      		ldi r24,lo8(4)
 746:stk500boot.c  **** 
 3156               		.loc 1 746 0
 3157 0cde 00C0      		rjmp .L149
 3158               	.LVL335:
 3159               	.L202:
 703:stk500boot.c  **** 				}
 3160               		.loc 1 703 0
 3161 0ce0 F12C      		mov r15,__zero_reg__
 3162 0ce2 E12C      		mov r14,__zero_reg__
 749:stk500boot.c  **** 						{
 3163               		.loc 1 749 0
 3164 0ce4 9E30      		cpi r25,lo8(14)
 3165 0ce6 01F0      		breq .+2
 3166 0ce8 00C0      		rjmp .L206
 3167               	.LVL336:
 752:stk500boot.c  **** 							ii				=	0;
 3168               		.loc 1 752 0
 3169 0cea B926      		eor r11,r25
 3170               	.LVL337:
 753:stk500boot.c  **** 						}
 3171               		.loc 1 753 0
 3172 0cec CE5D      		subi r28,lo8(-290)
 3173 0cee DE4F      		sbci r29,hi8(-290)
 3174 0cf0 1982      		std Y+1,__zero_reg__
 3175 0cf2 1882      		st Y,__zero_reg__
 3176 0cf4 C252      		subi r28,lo8(290)
 3177 0cf6 D140      		sbci r29,hi8(290)
 3178               	.LVL338:
 3179               	.L269:
 764:stk500boot.c  **** 						{
 3180               		.loc 1 764 0
 3181 0cf8 85E0      		ldi r24,lo8(5)
 3182 0cfa 00C0      		rjmp .L149
 3183               	.LVL339:
 3184               	.L203:
 703:stk500boot.c  **** 				}
 3185               		.loc 1 703 0
 3186 0cfc F12C      		mov r15,__zero_reg__
 3187 0cfe E12C      		mov r14,__zero_reg__
 3188               	.LVL340:
 3189               	.L145:
 762:stk500boot.c  **** 						checksum		^=	c;
 3190               		.loc 1 762 0
 3191 0d00 CE5D      		subi r28,lo8(-290)
 3192 0d02 DE4F      		sbci r29,hi8(-290)
 3193 0d04 4881      		ld r20,Y
 3194 0d06 5981      		ldd r21,Y+1
 3195 0d08 C252      		subi r28,lo8(290)
 3196 0d0a D140      		sbci r29,hi8(290)
 3197 0d0c 4F5F      		subi r20,-1
 3198 0d0e 5F4F      		sbci r21,-1
 3199               	.LVL341:
 3200 0d10 CE5D      		subi r28,lo8(-290)
 3201 0d12 DE4F      		sbci r29,hi8(-290)
 3202 0d14 E881      		ld r30,Y
 3203 0d16 F981      		ldd r31,Y+1
 3204 0d18 C252      		subi r28,lo8(290)
 3205 0d1a D140      		sbci r29,hi8(290)
 3206 0d1c E60D      		add r30,r6
 3207 0d1e F71D      		adc r31,r7
 3208 0d20 9083      		st Z,r25
 763:stk500boot.c  **** 						if (ii == msgLength )
 3209               		.loc 1 763 0
 3210 0d22 B926      		eor r11,r25
 3211               	.LVL342:
 764:stk500boot.c  **** 						{
 3212               		.loc 1 764 0
 3213 0d24 4217      		cp r20,r18
 3214 0d26 5307      		cpc r21,r19
 3215 0d28 01F4      		brne .+2
 3216 0d2a 00C0      		rjmp .L207
 3217 0d2c CE5D      		subi r28,lo8(-290)
 3218 0d2e DE4F      		sbci r29,hi8(-290)
 3219 0d30 5983      		std Y+1,r21
 3220 0d32 4883      		st Y,r20
 3221 0d34 C252      		subi r28,lo8(290)
 3222 0d36 D140      		sbci r29,hi8(290)
 3223 0d38 00C0      		rjmp .L269
 3224               	.LVL343:
 3225               	.L154:
 787:stk500boot.c  **** 			{
 3226               		.loc 1 787 0
 3227 0d3a 2131      		cpi r18,lo8(17)
 3228 0d3c 01F4      		brne .+2
 3229 0d3e 00C0      		rjmp .L209
 3230 0d40 00F0      		brlo .+2
 3231 0d42 00C0      		rjmp .L159
 3232 0d44 2031      		cpi r18,lo8(16)
 3233 0d46 01F4      		brne .+2
 3234 0d48 00C0      		rjmp .L280
 3235               	.L150:
 3236               	.LVL344:
1081:stk500boot.c  **** 					break;
 3237               		.loc 1 1081 0
 3238 0d4a 80EC      		ldi r24,lo8(-64)
 3239 0d4c 8A83      		std Y+2,r24
 3240 0d4e 00C0      		rjmp .L277
 3241               	.LVL345:
 3242               	.L152:
 787:stk500boot.c  **** 			{
 3243               		.loc 1 787 0
 3244 0d50 2831      		cpi r18,lo8(24)
 3245 0d52 01F4      		brne .+2
 3246 0d54 00C0      		rjmp .L160
 3247 0d56 00F4      		brsh .L161
 3248 0d58 2531      		cpi r18,lo8(21)
 3249 0d5a 01F4      		brne .+2
 3250 0d5c 00C0      		rjmp .L151
 3251 0d5e 00F0      		brlo .L162
 3252 0d60 2631      		cpi r18,lo8(22)
 3253 0d62 01F4      		brne .L150
 3254               	.L162:
 3255 0d64 8A81      		ldd r24,Y+2
 3256 0d66 9B81      		ldd r25,Y+3
 3257 0d68 9827      		eor r25,r24
 3258 0d6a 8927      		eor r24,r25
 3259 0d6c 9827      		eor r25,r24
 3260               	.LVL346:
 3261               	.LBB234:
1042:stk500boot.c  **** 
 3262               		.loc 1 1042 0
 3263 0d6e 8C01      		movw r16,r24
 3264 0d70 0D5F      		subi r16,-3
 3265 0d72 1F4F      		sbci r17,-1
 3266               	.LVL347:
1044:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3267               		.loc 1 1044 0
 3268 0d74 1A82      		std Y+2,__zero_reg__
1045:stk500boot.c  **** 						{
 3269               		.loc 1 1045 0
 3270 0d76 2431      		cpi r18,lo8(20)
 3271 0d78 01F0      		breq .+2
 3272 0d7a 00C0      		rjmp .L186
 3273 0d7c D301      		movw r26,r6
 3274               	.LVL348:
 3275               	.L187:
 3276               	.LBB235:
 3277               	.LBB236:
1053:stk500boot.c  **** 						#else
 3278               		.loc 1 1053 0 discriminator 1
 3279               	/* #APP */
 3280               	 ;  1053 "stk500boot.c" 1
 3281 0d7e 4BBE      		out 59, r4
 3282 0d80 F101      		movw r30, r2
 3283 0d82 2791      		elpm r18, Z+
 3284 0d84 3691      		elpm r19, Z
 3285               		
 3286               	 ;  0 "" 2
 3287               	.LVL349:
 3288               	/* #NOAPP */
 3289               	.LBE236:
1057:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 3290               		.loc 1 1057 0 discriminator 1
 3291 0d86 1296      		adiw r26,2
 3292 0d88 2C93      		st X,r18
 3293 0d8a 1297      		sbiw r26,2
 3294 0d8c FD01      		movw r30,r26
 3295 0d8e 3496      		adiw r30,4
 3296               	.LVL350:
1058:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 3297               		.loc 1 1058 0 discriminator 1
 3298 0d90 1396      		adiw r26,3
 3299 0d92 3C93      		st X,r19
 3300 0d94 1397      		sbiw r26,3
1059:stk500boot.c  **** 								size	-=	2;
 3301               		.loc 1 1059 0 discriminator 1
 3302 0d96 22E0      		ldi r18,2
 3303 0d98 220E      		add r2,r18
 3304 0d9a 311C      		adc r3,__zero_reg__
 3305 0d9c 411C      		adc r4,__zero_reg__
 3306 0d9e 511C      		adc r5,__zero_reg__
 3307               	.LVL351:
1060:stk500boot.c  **** 							}while (size);
 3308               		.loc 1 1060 0 discriminator 1
 3309 0da0 0297      		sbiw r24,2
 3310               	.LVL352:
 3311 0da2 1296      		adiw r26,2
1061:stk500boot.c  **** 						}
 3312               		.loc 1 1061 0 discriminator 1
 3313 0da4 0097      		sbiw r24,0
 3314 0da6 01F4      		brne .L187
 3315               	.LVL353:
 3316               	.L188:
 3317               	.LBE235:
1075:stk500boot.c  **** 					}
 3318               		.loc 1 1075 0
 3319 0da8 1082      		st Z,__zero_reg__
 3320               	.LBE234:
1077:stk500boot.c  **** 
 3321               		.loc 1 1077 0
 3322 0daa 00C0      		rjmp .L170
 3323               	.LVL354:
 3324               	.L161:
 787:stk500boot.c  **** 			{
 3325               		.loc 1 787 0
 3326 0dac 2A31      		cpi r18,lo8(26)
 3327 0dae 01F4      		brne .+2
 3328 0db0 00C0      		rjmp .L163
 3329 0db2 00F4      		brsh .+2
 3330 0db4 00C0      		rjmp .L164
 3331 0db6 2B31      		cpi r18,lo8(27)
 3332 0db8 01F4      		brne .+2
 3333 0dba 00C0      		rjmp .L165
 3334 0dbc 2D31      		cpi r18,lo8(29)
 3335 0dbe 01F0      		breq .+2
 3336 0dc0 00C0      		rjmp .L150
 3337               	.LVL355:
 3338               	.LBB237:
 795:stk500boot.c  **** 						{
 3339               		.loc 1 795 0
 3340 0dc2 9D81      		ldd r25,Y+5
 3341 0dc4 9033      		cpi r25,lo8(48)
 3342 0dc6 01F0      		breq .+2
 3343 0dc8 00C0      		rjmp .L167
 3344               	.LBB238:
 797:stk500boot.c  **** 
 3345               		.loc 1 797 0
 3346 0dca 8F81      		ldd r24,Y+7
 3347               	.LVL356:
 799:stk500boot.c  **** 							{
 3348               		.loc 1 799 0
 3349 0dcc 8823      		tst r24
 3350 0dce 01F4      		brne .+2
 3351 0dd0 00C0      		rjmp .L210
 803:stk500boot.c  **** 							{
 3352               		.loc 1 803 0
 3353 0dd2 8130      		cpi r24,lo8(1)
 3354 0dd4 01F0      		breq .+2
 3355 0dd6 00C0      		rjmp .L211
 805:stk500boot.c  **** 							}
 3356               		.loc 1 805 0
 3357 0dd8 88E9      		ldi r24,lo8(-104)
 3358               	.LVL357:
 3359               	.L168:
 3360               	.LBE238:
 839:stk500boot.c  **** 							msgBuffer[2]	=	0;
 3361               		.loc 1 839 0
 3362 0dda 1A82      		std Y+2,__zero_reg__
 840:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 3363               		.loc 1 840 0
 3364 0ddc 1B82      		std Y+3,__zero_reg__
 841:stk500boot.c  **** 							msgBuffer[4]	=	0;
 3365               		.loc 1 841 0
 3366 0dde 9C83      		std Y+4,r25
 842:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 3367               		.loc 1 842 0
 3368 0de0 1D82      		std Y+5,__zero_reg__
 843:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 3369               		.loc 1 843 0
 3370 0de2 8E83      		std Y+6,r24
 844:stk500boot.c  **** 						}
 3371               		.loc 1 844 0
 3372 0de4 1F82      		std Y+7,__zero_reg__
 838:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 3373               		.loc 1 838 0
 3374 0de6 07E0      		ldi r16,lo8(7)
 3375 0de8 10E0      		ldi r17,0
 3376               	.LVL358:
 3377               	.L170:
 3378               	.LBE237:
1088:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
 3379               		.loc 1 1088 0
 3380 0dea 8BE1      		ldi r24,lo8(27)
 3381 0dec 0E94 0000 		call sendchar
 3382               	.LVL359:
1091:stk500boot.c  **** 			checksum	^=	seqNum;
 3383               		.loc 1 1091 0
 3384 0df0 C85D      		subi r28,lo8(-296)
 3385 0df2 DE4F      		sbci r29,hi8(-296)
 3386 0df4 8881      		ld r24,Y
 3387 0df6 C852      		subi r28,lo8(296)
 3388 0df8 D140      		sbci r29,hi8(296)
 3389 0dfa 0E94 0000 		call sendchar
 3390               	.LVL360:
1095:stk500boot.c  **** 			checksum	^=	c;
 3391               		.loc 1 1095 0
 3392 0dfe 812F      		mov r24,r17
 3393 0e00 0E94 0000 		call sendchar
 3394               	.LVL361:
1099:stk500boot.c  **** 			checksum ^= c;
 3395               		.loc 1 1099 0
 3396 0e04 802F      		mov r24,r16
 3397 0e06 0E94 0000 		call sendchar
 3398               	.LVL362:
 3399 0e0a 95E1      		ldi r25,lo8(21)
 3400 0e0c B92E      		mov r11,r25
 3401 0e0e C85D      		subi r28,lo8(-296)
 3402 0e10 DE4F      		sbci r29,hi8(-296)
 3403 0e12 3881      		ld r19,Y
 3404 0e14 C852      		subi r28,lo8(296)
 3405 0e16 D140      		sbci r29,hi8(296)
 3406 0e18 B326      		eor r11,r19
 3407 0e1a B026      		eor r11,r16
 3408               	.LVL363:
1102:stk500boot.c  **** 			checksum ^= TOKEN;
 3409               		.loc 1 1102 0
 3410 0e1c 8EE0      		ldi r24,lo8(14)
 3411 0e1e 0E94 0000 		call sendchar
 3412               	.LVL364:
1103:stk500boot.c  **** 
 3413               		.loc 1 1103 0
 3414 0e22 B126      		eor r11,r17
 3415               	.LVL365:
 3416 0e24 AE01      		movw r20,r28
 3417 0e26 4F5F      		subi r20,-1
 3418 0e28 5F4F      		sbci r21,-1
 3419 0e2a 6A01      		movw r12,r20
 3420 0e2c 040F      		add r16,r20
 3421 0e2e 151F      		adc r17,r21
 3422               	.LVL366:
 3423               	.L190:
1106:stk500boot.c  **** 			{
 3424               		.loc 1 1106 0
 3425 0e30 0C15      		cp r16,r12
 3426 0e32 1D05      		cpc r17,r13
 3427 0e34 01F0      		breq .+2
 3428 0e36 00C0      		rjmp .L191
1113:stk500boot.c  **** 			seqNum++;
 3429               		.loc 1 1113 0
 3430 0e38 8B2D      		mov r24,r11
 3431 0e3a 0E94 0000 		call sendchar
 3432               	.LVL367:
1114:stk500boot.c  **** 	
 3433               		.loc 1 1114 0
 3434 0e3e C85D      		subi r28,lo8(-296)
 3435 0e40 DE4F      		sbci r29,hi8(-296)
 3436 0e42 B881      		ld r27,Y
 3437 0e44 C852      		subi r28,lo8(296)
 3438 0e46 D140      		sbci r29,hi8(296)
 3439 0e48 BF5F      		subi r27,lo8(-(1))
 3440 0e4a C85D      		subi r28,lo8(-296)
 3441 0e4c DE4F      		sbci r29,hi8(-296)
 3442 0e4e B883      		st Y,r27
 3443 0e50 C852      		subi r28,lo8(296)
 3444 0e52 D140      		sbci r29,hi8(296)
 3445               	.LVL368:
1118:stk500boot.c  **** 		#endif
 3446               		.loc 1 1118 0
 3447 0e54 85B1      		in r24,0x5
 3448 0e56 8058      		subi r24,lo8(-(-128))
 3449 0e58 85B9      		out 0x5,r24
 3450               	.LVL369:
 666:stk500boot.c  **** 		{
 3451               		.loc 1 666 0
 3452 0e5a C25E      		subi r28,lo8(-286)
 3453 0e5c DE4F      		sbci r29,hi8(-286)
 3454 0e5e E881      		ld r30,Y
 3455 0e60 CE51      		subi r28,lo8(286)
 3456 0e62 D140      		sbci r29,hi8(286)
 3457 0e64 EE23      		tst r30
 3458 0e66 01F4      		brne .+2
 3459 0e68 00C0      		rjmp .L216
 3460               	.LVL370:
 3461               	.L49:
1153:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 3462               		.loc 1 1153 0
 3463 0e6a 2798      		cbi 0x4,7
1154:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
 3464               		.loc 1 1154 0
 3465 0e6c 2F98      		cbi 0x5,7
1156:stk500boot.c  **** #endif
 3466               		.loc 1 1156 0
 3467 0e6e 84E6      		ldi r24,lo8(100)
 3468 0e70 90E0      		ldi r25,0
 3469 0e72 0E94 0000 		call delay_ms
 3470               	.LVL371:
1160:stk500boot.c  **** 
 3471               		.loc 1 1160 0
 3472               	/* #APP */
 3473               	 ;  1160 "stk500boot.c" 1
 3474 0e76 0000      		nop
 3475               	 ;  0 "" 2
1166:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 3476               		.loc 1 1166 0
 3477               	/* #NOAPP */
 3478 0e78 8091 C800 		lds r24,200
 3479 0e7c 8D7F      		andi r24,lo8(-3)
 3480 0e7e 8093 C800 		sts 200,r24
1167:stk500boot.c  **** 
 3481               		.loc 1 1167 0
 3482 0e82 81E1      		ldi r24,lo8(17)
 3483               	/* #APP */
 3484               	 ;  1167 "stk500boot.c" 1
 3485 0e84 8093 5700 		sts 87, r24
 3486 0e88 E895      		spm
 3487               		
 3488               	 ;  0 "" 2
1170:stk500boot.c  **** 			"clr	r30		\n\t"
 3489               		.loc 1 1170 0
 3490               	 ;  1170 "stk500boot.c" 1
 3491 0e8a EE27      		clr	r30		
 3492 0e8c FF27      		clr	r31		
 3493 0e8e 0994      		ijmp	
 3494               		
 3495               	 ;  0 "" 2
 3496               	/* #NOAPP */
 3497               	.L192:
 3498 0e90 00C0      		rjmp .L192
 3499               	.LVL372:
 3500               	.L167:
 3501 0e92 892F      		mov r24,r25
 3502 0e94 8075      		andi r24,lo8(80)
 3503               	.LBB242:
 812:stk500boot.c  **** 						{
 3504               		.loc 1 812 0
 3505 0e96 01F4      		brne .+2
 3506 0e98 00C0      		rjmp .L168
 3507               	.LBB239:
 821:stk500boot.c  **** 							}
 3508               		.loc 1 821 0
 3509 0e9a 89E0      		ldi r24,lo8(9)
 3510 0e9c F0E0      		ldi r31,0
 3511 0e9e E0E0      		ldi r30,0
 3512               	.LBE239:
 819:stk500boot.c  **** 							{
 3513               		.loc 1 819 0
 3514 0ea0 9035      		cpi r25,lo8(80)
 3515 0ea2 01F0      		breq .L274
 834:stk500boot.c  **** 						}
 3516               		.loc 1 834 0
 3517 0ea4 80E0      		ldi r24,0
 823:stk500boot.c  **** 							{
 3518               		.loc 1 823 0
 3519 0ea6 9835      		cpi r25,lo8(88)
 3520 0ea8 01F0      		breq .+2
 3521 0eaa 00C0      		rjmp .L168
 3522               	.LBB240:
 825:stk500boot.c  **** 							}
 3523               		.loc 1 825 0
 3524 0eac 89E0      		ldi r24,lo8(9)
 3525 0eae E3E0      		ldi r30,lo8(3)
 3526 0eb0 F0E0      		ldi r31,0
 3527               	.L274:
 3528               	/* #APP */
 3529               	 ;  825 "stk500boot.c" 1
 3530 0eb2 8093 5700 		sts 87, r24
 3531 0eb6 8491      		lpm r24, Z
 3532               		
 3533               	 ;  0 "" 2
 3534               	.LVL373:
 3535               	/* #NOAPP */
 3536               	.LBE240:
 3537 0eb8 00C0      		rjmp .L168
 3538               	.LVL374:
 3539               	.L210:
 3540               	.LBB241:
 801:stk500boot.c  **** 							}
 3541               		.loc 1 801 0
 3542 0eba 8EE1      		ldi r24,lo8(30)
 3543               	.LVL375:
 3544 0ebc 00C0      		rjmp .L168
 3545               	.LVL376:
 3546               	.L211:
 809:stk500boot.c  **** 							}
 3547               		.loc 1 809 0
 3548 0ebe 81E0      		ldi r24,lo8(1)
 3549               	.LVL377:
 3550 0ec0 00C0      		rjmp .L168
 3551               	.LVL378:
 3552               	.L156:
 3553 0ec2 EA81      		ldd r30,Y+2
 3554 0ec4 E059      		subi r30,lo8(-(112))
 3555               	.LBE241:
 3556               	.LBE242:
 3557               	.LBB243:
 867:stk500boot.c  **** 						{
 3558               		.loc 1 867 0
 3559 0ec6 80E0      		ldi r24,0
 3560 0ec8 E330      		cpi r30,lo8(3)
 3561 0eca 00F4      		brsh .L171
 3562 0ecc F0E0      		ldi r31,0
 3563 0ece E050      		subi r30,lo8(-(CSWTCH.59))
 3564 0ed0 F040      		sbci r31,hi8(-(CSWTCH.59))
 3565 0ed2 8081      		ld r24,Z
 3566               	.L171:
 3567               	.LVL379:
 889:stk500boot.c  **** 						msgBuffer[2]	=	value;
 3568               		.loc 1 889 0
 3569 0ed4 1A82      		std Y+2,__zero_reg__
 890:stk500boot.c  **** 					}
 3570               		.loc 1 890 0
 3571 0ed6 8B83      		std Y+3,r24
 3572               	.LVL380:
 3573               	.L276:
 3574               	.LBE243:
 3575               	.LBB244:
 961:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3576               		.loc 1 961 0
 3577 0ed8 03E0      		ldi r16,lo8(3)
 3578 0eda 10E0      		ldi r17,0
 3579               	.LBE244:
 965:stk500boot.c  **** 	#endif
 3580               		.loc 1 965 0
 3581 0edc 00C0      		rjmp .L170
 3582               	.LVL381:
 3583               	.L209:
 895:stk500boot.c  **** 					//*	fall thru
 3584               		.loc 1 895 0
 3585 0ede F1E0      		ldi r31,lo8(1)
 3586 0ee0 C25E      		subi r28,lo8(-286)
 3587 0ee2 DE4F      		sbci r29,hi8(-286)
 3588 0ee4 F883      		st Y,r31
 3589 0ee6 CE51      		subi r28,lo8(286)
 3590 0ee8 D140      		sbci r29,hi8(286)
 3591               	.LVL382:
 3592               	.L280:
 981:stk500boot.c  **** 					break;
 3593               		.loc 1 981 0
 3594 0eea 1A82      		std Y+2,__zero_reg__
 3595               	.LVL383:
 3596               	.L277:
1080:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 3597               		.loc 1 1080 0
 3598 0eec 02E0      		ldi r16,lo8(2)
 3599 0eee 10E0      		ldi r17,0
1082:stk500boot.c  **** 			}
 3600               		.loc 1 1082 0
 3601 0ef0 00C0      		rjmp .L170
 3602               	.LVL384:
 3603               	.L165:
 3604               	.LBB246:
 906:stk500boot.c  **** 						unsigned char signature;
 3605               		.loc 1 906 0
 3606 0ef2 8D81      		ldd r24,Y+5
 3607               	.LVL385:
 909:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 3608               		.loc 1 909 0
 3609 0ef4 8823      		tst r24
 3610 0ef6 01F0      		breq .L214
 911:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 3611               		.loc 1 911 0
 3612 0ef8 8130      		cpi r24,lo8(1)
 3613 0efa 01F4      		brne .L215
 912:stk500boot.c  **** 						else
 3614               		.loc 1 912 0
 3615 0efc 88E9      		ldi r24,lo8(-104)
 3616               	.LVL386:
 3617               	.L279:
 3618               	.LBE246:
 3619               	.LBB247:
 946:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 3620               		.loc 1 946 0
 3621 0efe 1A82      		std Y+2,__zero_reg__
 3622 0f00 00C0      		rjmp .L278
 3623               	.LVL387:
 3624               	.L214:
 3625               	.LBE247:
 3626               	.LBB252:
 910:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 3627               		.loc 1 910 0
 3628 0f02 8EE1      		ldi r24,lo8(30)
 3629               	.LVL388:
 3630 0f04 00C0      		rjmp .L279
 3631               	.LVL389:
 3632               	.L215:
 914:stk500boot.c  **** 
 3633               		.loc 1 914 0
 3634 0f06 81E0      		ldi r24,lo8(1)
 3635               	.LVL390:
 3636 0f08 00C0      		rjmp .L279
 3637               	.LVL391:
 3638               	.L163:
 3639               	.LBE252:
 925:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 3640               		.loc 1 925 0
 3641 0f0a 1A82      		std Y+2,__zero_reg__
 3642               	.LBB253:
 926:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 3643               		.loc 1 926 0
 3644 0f0c 89E0      		ldi r24,lo8(9)
 3645 0f0e E1E0      		ldi r30,lo8(1)
 3646 0f10 F0E0      		ldi r31,0
 3647               	/* #APP */
 3648               	 ;  926 "stk500boot.c" 1
 3649 0f12 8093 5700 		sts 87, r24
 3650 0f16 8491      		lpm r24, Z
 3651               		
 3652               	 ;  0 "" 2
 3653               	/* #NOAPP */
 3654               	.L278:
 3655               	.LVL392:
 3656               	.LBE253:
 3657 0f18 8B83      		std Y+3,r24
 927:stk500boot.c  **** 					break;
 3658               		.loc 1 927 0
 3659 0f1a 1C82      		std Y+4,__zero_reg__
 924:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3660               		.loc 1 924 0
 3661 0f1c 04E0      		ldi r16,lo8(4)
 3662 0f1e 10E0      		ldi r17,0
 928:stk500boot.c  **** 
 3663               		.loc 1 928 0
 3664 0f20 00C0      		rjmp .L170
 3665               	.LVL393:
 3666               	.L160:
 3667               	.LBB254:
 934:stk500boot.c  **** 						{
 3668               		.loc 1 934 0
 3669 0f22 8B81      		ldd r24,Y+3
 3670 0f24 8035      		cpi r24,lo8(80)
 3671 0f26 01F4      		brne .L173
 936:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3672               		.loc 1 936 0
 3673 0f28 8C81      		ldd r24,Y+4
 3674 0f2a 8830      		cpi r24,lo8(8)
 3675 0f2c 01F4      		brne .L174
 3676               	.LBB248:
 937:stk500boot.c  **** 							else
 3677               		.loc 1 937 0
 3678 0f2e 89E0      		ldi r24,lo8(9)
 3679 0f30 E2E0      		ldi r30,lo8(2)
 3680 0f32 F0E0      		ldi r31,0
 3681               	.L275:
 3682               	.LBE248:
 3683               	.LBB249:
 943:stk500boot.c  **** 						}
 3684               		.loc 1 943 0
 3685               	/* #APP */
 3686               	 ;  943 "stk500boot.c" 1
 3687 0f34 8093 5700 		sts 87, r24
 3688 0f38 8491      		lpm r24, Z
 3689               		
 3690               	 ;  0 "" 2
 3691               	.LVL394:
 3692               	/* #NOAPP */
 3693 0f3a 00C0      		rjmp .L279
 3694               	.LVL395:
 3695               	.L174:
 3696               	.LBE249:
 3697               	.LBB250:
 939:stk500boot.c  **** 						}
 3698               		.loc 1 939 0
 3699 0f3c 89E0      		ldi r24,lo8(9)
 3700 0f3e F0E0      		ldi r31,0
 3701 0f40 E0E0      		ldi r30,0
 3702 0f42 00C0      		rjmp .L275
 3703               	.L173:
 3704               	.LBE250:
 3705               	.LBB251:
 943:stk500boot.c  **** 						}
 3706               		.loc 1 943 0
 3707 0f44 89E0      		ldi r24,lo8(9)
 3708 0f46 E3E0      		ldi r30,lo8(3)
 3709 0f48 F0E0      		ldi r31,0
 3710 0f4a 00C0      		rjmp .L275
 3711               	.L164:
 3712               	.LVL396:
 3713               	.LBE251:
 3714               	.LBE254:
 3715               	.LBB255:
 957:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 3716               		.loc 1 957 0
 3717 0f4c 8D81      		ldd r24,Y+5
 3718               	.LVL397:
 3719               	.LBB245:
 958:stk500boot.c  **** 						boot_spm_busy_wait();
 3720               		.loc 1 958 0
 3721 0f4e 836C      		ori r24,lo8(-61)
 3722               	.LVL398:
 3723 0f50 99E0      		ldi r25,lo8(9)
 3724               	/* #APP */
 3725               	 ;  958 "stk500boot.c" 1
 3726 0f52 E1E0      		ldi r30, 1
 3727 0f54 F0E0      		ldi r31, 0
 3728 0f56 082E      		mov r0, r24
 3729 0f58 9093 5700 		sts 87, r25
 3730 0f5c E895      		spm
 3731               		
 3732               	 ;  0 "" 2
 3733               	/* #NOAPP */
 3734               	.L176:
 3735               	.LBE245:
 959:stk500boot.c  **** 
 3736               		.loc 1 959 0 discriminator 1
 3737 0f5e 07B6      		in __tmp_reg__,0x37
 3738 0f60 00FC      		sbrc __tmp_reg__,0
 3739 0f62 00C0      		rjmp .L176
 3740               	.LVL399:
 962:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 3741               		.loc 1 962 0
 3742 0f64 1A82      		std Y+2,__zero_reg__
 963:stk500boot.c  **** 					}
 3743               		.loc 1 963 0
 3744 0f66 1B82      		std Y+3,__zero_reg__
 3745 0f68 00C0      		rjmp .L276
 3746               	.LVL400:
 3747               	.L159:
 3748               	.LBE255:
 971:stk500boot.c  **** 					break;
 3749               		.loc 1 971 0
 3750 0f6a 80EC      		ldi r24,lo8(-64)
 3751 0f6c 8A83      		std Y+2,r24
 969:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 3752               		.loc 1 969 0
 3753 0f6e 02E0      		ldi r16,lo8(2)
 3754 0f70 10E0      		ldi r17,0
 968:stk500boot.c  **** 					msgLength		=	2;
 3755               		.loc 1 968 0
 3756 0f72 CC5D      		subi r28,lo8(-292)
 3757 0f74 DE4F      		sbci r29,hi8(-292)
 3758 0f76 1882      		st Y,__zero_reg__
 3759 0f78 1982      		std Y+1,__zero_reg__
 3760 0f7a 1A82      		std Y+2,__zero_reg__
 3761 0f7c 1B82      		std Y+3,__zero_reg__
 3762 0f7e C452      		subi r28,lo8(292)
 3763 0f80 D140      		sbci r29,hi8(292)
 972:stk500boot.c  **** 
 3764               		.loc 1 972 0
 3765 0f82 00C0      		rjmp .L170
 3766               	.LVL401:
 3767               	.L153:
 3768 0f84 6A81      		ldd r22,Y+2
 3769 0f86 7B81      		ldd r23,Y+3
 3770 0f88 8C81      		ldd r24,Y+4
 3771 0f8a 9D81      		ldd r25,Y+5
 3772 0f8c 0E94 0000 		call __bswapsi2
 976:stk500boot.c  **** 	#else
 3773               		.loc 1 976 0
 3774 0f90 1B01      		movw r2,r22
 3775 0f92 2C01      		movw r4,r24
 3776 0f94 220C      		lsl r2
 3777 0f96 331C      		rol r3
 3778 0f98 441C      		rol r4
 3779 0f9a 551C      		rol r5
 3780 0f9c 00C0      		rjmp .L280
 3781               	.L151:
 3782 0f9e 0A81      		ldd r16,Y+2
 3783 0fa0 1B81      		ldd r17,Y+3
 3784 0fa2 1027      		eor r17,r16
 3785 0fa4 0127      		eor r16,r17
 3786 0fa6 1027      		eor r17,r16
 3787               	.LVL402:
 3788               	.LBB256:
 994:stk500boot.c  **** 						{
 3789               		.loc 1 994 0
 3790 0fa8 2331      		cpi r18,lo8(19)
 3791 0faa 01F0      		breq .+2
 3792 0fac 00C0      		rjmp .L177
 997:stk500boot.c  **** 							{
 3793               		.loc 1 997 0
 3794 0fae CC5D      		subi r28,lo8(-292)
 3795 0fb0 DE4F      		sbci r29,hi8(-292)
 3796 0fb2 2881      		ld r18,Y
 3797 0fb4 3981      		ldd r19,Y+1
 3798 0fb6 4A81      		ldd r20,Y+2
 3799 0fb8 5B81      		ldd r21,Y+3
 3800 0fba C452      		subi r28,lo8(292)
 3801 0fbc D140      		sbci r29,hi8(292)
 3802 0fbe 2115      		cp r18,__zero_reg__
 3803 0fc0 80EC      		ldi r24,-64
 3804 0fc2 3807      		cpc r19,r24
 3805 0fc4 83E0      		ldi r24,3
 3806 0fc6 4807      		cpc r20,r24
 3807 0fc8 5105      		cpc r21,__zero_reg__
 3808 0fca 00F4      		brsh .L178
 999:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 3809               		.loc 1 999 0
 3810 0fcc 83E0      		ldi r24,lo8(3)
 3811               	/* #APP */
 3812               	 ;  999 "stk500boot.c" 1
 3813 0fce F901      		movw r30, r18
 3814 0fd0 4093 5B00 		sts  91, r20
 3815 0fd4 8093 5700 		sts 87, r24
 3816 0fd8 E895      		spm
 3817               		
 3818               	 ;  0 "" 2
 3819               	/* #NOAPP */
 3820               	.L179:
1000:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 3821               		.loc 1 1000 0 discriminator 1
 3822 0fda 07B6      		in __tmp_reg__,0x37
 3823 0fdc 00FC      		sbrc __tmp_reg__,0
 3824 0fde 00C0      		rjmp .L179
1001:stk500boot.c  **** 							}
 3825               		.loc 1 1001 0
 3826 0fe0 CC5D      		subi r28,lo8(-292)
 3827 0fe2 DE4F      		sbci r29,hi8(-292)
 3828 0fe4 2881      		ld r18,Y
 3829 0fe6 3981      		ldd r19,Y+1
 3830 0fe8 4A81      		ldd r20,Y+2
 3831 0fea 5B81      		ldd r21,Y+3
 3832 0fec C452      		subi r28,lo8(292)
 3833 0fee D140      		sbci r29,hi8(292)
 3834 0ff0 3F5F      		subi r19,-1
 3835 0ff2 4F4F      		sbci r20,-1
 3836 0ff4 5F4F      		sbci r21,-1
 3837 0ff6 CC5D      		subi r28,lo8(-292)
 3838 0ff8 DE4F      		sbci r29,hi8(-292)
 3839 0ffa 2883      		st Y,r18
 3840 0ffc 3983      		std Y+1,r19
 3841 0ffe 4A83      		std Y+2,r20
 3842 1000 5B83      		std Y+3,r21
 3843 1002 C452      		subi r28,lo8(292)
 3844 1004 D140      		sbci r29,hi8(292)
 3845               	.LVL403:
 3846               	.L178:
 3847 1006 8B85      		ldd r24,Y+11
 3848 1008 DE01      		movw r26,r28
 3849 100a 1196      		adiw r26,1
 3850               	.LBE256:
 3851               	.LBB258:
 914:stk500boot.c  **** 
 3852               		.loc 1 914 0 discriminator 1
 3853 100c B201      		movw r22,r4
 3854 100e A101      		movw r20,r2
 3855               	.LBE258:
 3856               	.LBB259:
1010:stk500boot.c  **** 
 3857               		.loc 1 1010 0 discriminator 1
 3858 1010 21E0      		ldi r18,lo8(1)
 3859               	.L181:
 3860               	.LVL404:
1009:stk500boot.c  **** 								boot_page_fill(address,data);
 3861               		.loc 1 1009 0 discriminator 1
 3862 1012 1B96      		adiw r26,11
 3863 1014 9C91      		ld r25,X
 3864 1016 1B97      		sbiw r26,11
1010:stk500boot.c  **** 
 3865               		.loc 1 1010 0 discriminator 1
 3866               	/* #APP */
 3867               	 ;  1010 "stk500boot.c" 1
 3868 1018 0C01      		movw  r0, r24
 3869 101a FA01      		movw r30, r20
 3870 101c 6093 5B00 		sts 91, r22
 3871 1020 2093 5700 		sts 87, r18
 3872 1024 E895      		spm
 3873 1026 1124      		clr  r1
 3874               		
 3875               	 ;  0 "" 2
1012:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3876               		.loc 1 1012 0 discriminator 1
 3877               	/* #NOAPP */
 3878 1028 4E5F      		subi r20,-2
 3879 102a 5F4F      		sbci r21,-1
 3880 102c 6F4F      		sbci r22,-1
 3881 102e 7F4F      		sbci r23,-1
 3882               	.LVL405:
1013:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 3883               		.loc 1 1013 0 discriminator 1
 3884 1030 0250      		subi r16,2
 3885 1032 1109      		sbc r17,__zero_reg__
 3886               	.LVL406:
 3887 1034 1296      		adiw r26,2
 3888               	.LVL407:
1014:stk500boot.c  **** 
 3889               		.loc 1 1014 0 discriminator 1
 3890 1036 0115      		cp r16,__zero_reg__
 3891 1038 1105      		cpc r17,__zero_reg__
 3892 103a 01F0      		breq .L180
1007:stk500boot.c  **** 
 3893               		.loc 1 1007 0
 3894 103c 1A96      		adiw r26,10
 3895 103e 8C91      		ld r24,X
 3896 1040 1A97      		sbiw r26,10
 3897               	.LVL408:
 3898 1042 00C0      		rjmp .L181
 3899               	.LVL409:
 3900               	.L180:
1016:stk500boot.c  **** 							boot_spm_busy_wait();
 3901               		.loc 1 1016 0
 3902 1044 35E0      		ldi r19,lo8(5)
 3903               	/* #APP */
 3904               	 ;  1016 "stk500boot.c" 1
 3905 1046 F101      		movw r30, r2
 3906 1048 4092 5B00 		sts 91, r4
 3907 104c 3093 5700 		sts 87, r19
 3908 1050 E895      		spm
 3909               		
 3910               	 ;  0 "" 2
 3911               	/* #NOAPP */
 3912               	.L182:
1017:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 3913               		.loc 1 1017 0 discriminator 1
 3914 1052 07B6      		in __tmp_reg__,0x37
 3915 1054 00FC      		sbrc __tmp_reg__,0
 3916 1056 00C0      		rjmp .L182
1018:stk500boot.c  **** 						}
 3917               		.loc 1 1018 0
 3918 1058 81E1      		ldi r24,lo8(17)
 3919               	.LVL410:
 3920               	/* #APP */
 3921               	 ;  1018 "stk500boot.c" 1
 3922 105a 8093 5700 		sts 87, r24
 3923 105e E895      		spm
 3924               		
 3925               	 ;  0 "" 2
 3926               	.LVL411:
 3927               	/* #NOAPP */
 3928               	.L183:
1033:stk500boot.c  **** 					}
 3929               		.loc 1 1033 0
 3930 1060 1A82      		std Y+2,__zero_reg__
 3931               	.LBE259:
1035:stk500boot.c  **** 
 3932               		.loc 1 1035 0
 3933 1062 1A01      		movw r2,r20
 3934               	.LVL412:
 3935 1064 2B01      		movw r4,r22
 3936 1066 00C0      		rjmp .L277
 3937               	.LVL413:
 3938               	.L177:
 3939               	.LBB260:
 3940               	.LBB257:
1023:stk500boot.c  **** 							/* write EEPROM */
 3941               		.loc 1 1023 0
 3942 1068 D201      		movw r26,r4
 3943 106a C101      		movw r24,r2
 3944 106c B695      		lsr r27
 3945 106e A795      		ror r26
 3946 1070 9795      		ror r25
 3947 1072 8795      		ror r24
 3948               	.LVL414:
 3949 1074 4301      		movw r8,r6
 3950 1076 800E      		add r8,r16
 3951 1078 911E      		adc r9,r17
1025:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3952               		.loc 1 1025 0
 3953 107a 6301      		movw r12,r6
1026:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 3954               		.loc 1 1026 0
 3955 107c 5C01      		movw r10,r24
 3956 107e A618      		sub r10,r6
 3957 1080 B708      		sbc r11,r7
 3958               	.LVL415:
 3959               	.L184:
1025:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3960               		.loc 1 1025 0
 3961 1082 8C14      		cp r8,r12
 3962 1084 9D04      		cpc r9,r13
 3963 1086 01F4      		brne .L185
 3964 1088 30E0      		ldi r19,0
 3965 108a 20E0      		ldi r18,0
 3966 108c 000F      		lsl r16
 3967 108e 111F      		rol r17
 3968 1090 221F      		rol r18
 3969 1092 331F      		rol r19
 3970 1094 B901      		movw r22,r18
 3971 1096 A801      		movw r20,r16
 3972 1098 420D      		add r20,r2
 3973 109a 531D      		adc r21,r3
 3974 109c 641D      		adc r22,r4
 3975 109e 751D      		adc r23,r5
 3976 10a0 00C0      		rjmp .L183
 3977               	.L185:
 3978               	.LVL416:
1026:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 3979               		.loc 1 1026 0
 3980 10a2 D601      		movw r26,r12
 3981 10a4 1A96      		adiw r26,10
 3982 10a6 6C91      		ld r22,X
 3983 10a8 C501      		movw r24,r10
 3984 10aa 8C0D      		add r24,r12
 3985 10ac 9D1D      		adc r25,r13
 3986 10ae 0E94 0000 		call eeprom_write_byte
 3987               	.LVL417:
 3988 10b2 BFEF      		ldi r27,-1
 3989 10b4 CB1A      		sub r12,r27
 3990 10b6 DB0A      		sbc r13,r27
 3991               	.LVL418:
 3992 10b8 00C0      		rjmp .L184
 3993               	.LVL419:
 3994               	.L186:
 3995 10ba F301      		movw r30,r6
 3996 10bc 9301      		movw r18,r6
 3997 10be 280F      		add r18,r24
 3998 10c0 391F      		adc r19,r25
 3999               	.LBE257:
 4000               	.LBE260:
 4001               	.LBB261:
1045:stk500boot.c  **** 						{
 4002               		.loc 1 1045 0
 4003 10c2 B201      		movw r22,r4
 4004 10c4 A101      		movw r20,r2
 4005               	.LVL420:
 4006               	.L189:
1067:stk500boot.c  **** 								EEARH	=	((address >> 8));
 4007               		.loc 1 1067 0 discriminator 1
 4008 10c6 41BD      		out 0x21,r20
1068:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 4009               		.loc 1 1068 0 discriminator 1
 4010 10c8 852E      		mov r8,r21
 4011 10ca 962E      		mov r9,r22
 4012 10cc A72E      		mov r10,r23
 4013 10ce BB24      		clr r11
 4014 10d0 82BC      		out 0x22,r8
1069:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 4015               		.loc 1 1069 0 discriminator 1
 4016 10d2 4F5F      		subi r20,-1
 4017 10d4 5F4F      		sbci r21,-1
 4018 10d6 6F4F      		sbci r22,-1
 4019 10d8 7F4F      		sbci r23,-1
 4020               	.LVL421:
1070:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 4021               		.loc 1 1070 0 discriminator 1
 4022 10da F89A      		sbi 0x1f,0
 4023               	.LVL422:
1071:stk500boot.c  **** 								size--;
 4024               		.loc 1 1071 0 discriminator 1
 4025 10dc A0B5      		in r26,0x20
 4026 10de A283      		std Z+2,r26
 4027 10e0 3196      		adiw r30,1
 4028               	.LVL423:
1073:stk500boot.c  **** 						}
 4029               		.loc 1 1073 0 discriminator 1
 4030 10e2 E217      		cp r30,r18
 4031 10e4 F307      		cpc r31,r19
 4032 10e6 01F4      		brne .L189
 4033 10e8 AC01      		movw r20,r24
 4034               	.LVL424:
 4035 10ea 4150      		subi r20,1
 4036 10ec 5109      		sbc r21,__zero_reg__
 4037 10ee 70E0      		ldi r23,0
 4038 10f0 60E0      		ldi r22,0
 4039 10f2 4F5F      		subi r20,-1
 4040 10f4 5F4F      		sbci r21,-1
 4041 10f6 6F4F      		sbci r22,-1
 4042 10f8 7F4F      		sbci r23,-1
 4043 10fa 240E      		add r2,r20
 4044 10fc 351E      		adc r3,r21
 4045 10fe 461E      		adc r4,r22
 4046 1100 571E      		adc r5,r23
 4047 1102 E3E0      		ldi r30,lo8(3)
 4048 1104 F0E0      		ldi r31,0
 4049               	.LVL425:
 4050 1106 EC0F      		add r30,r28
 4051 1108 FD1F      		adc r31,r29
 4052 110a E80F      		add r30,r24
 4053 110c F91F      		adc r31,r25
 4054 110e 00C0      		rjmp .L188
 4055               	.LVL426:
 4056               	.L191:
 4057               	.LBE261:
1108:stk500boot.c  **** 				sendchar(c);
 4058               		.loc 1 1108 0
 4059 1110 D601      		movw r26,r12
 4060 1112 AD90      		ld r10,X+
 4061               	.LVL427:
 4062 1114 6D01      		movw r12,r26
 4063               	.LVL428:
1109:stk500boot.c  **** 				checksum ^=c;
 4064               		.loc 1 1109 0
 4065 1116 8A2D      		mov r24,r10
 4066 1118 0E94 0000 		call sendchar
 4067               	.LVL429:
1110:stk500boot.c  **** 				msgLength--;
 4068               		.loc 1 1110 0
 4069 111c BA24      		eor r11,r10
 4070               	.LVL430:
 4071 111e 00C0      		rjmp .L190
 4072               	.LVL431:
 4073               	.L216:
 4074 1120 50E0      		ldi r21,0
 4075 1122 40E0      		ldi r20,0
 4076 1124 0C94 0000 		jmp .L48
 4077               	.LVL432:
 4078               	.L205:
 713:stk500boot.c  **** 						}
 4079               		.loc 1 713 0
 4080 1128 8BE1      		ldi r24,lo8(27)
 4081 112a B82E      		mov r11,r24
 4082               	.LVL433:
 712:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 4083               		.loc 1 712 0
 4084 112c 81E0      		ldi r24,lo8(1)
 4085 112e 00C0      		rjmp .L149
 4086               	.LVL434:
 4087               	.L207:
 4088 1130 CE5D      		subi r28,lo8(-290)
 4089 1132 DE4F      		sbci r29,hi8(-290)
 4090 1134 3983      		std Y+1,r19
 4091 1136 2883      		st Y,r18
 4092 1138 C252      		subi r28,lo8(290)
 4093 113a D140      		sbci r29,hi8(290)
 766:stk500boot.c  **** 						}
 4094               		.loc 1 766 0
 4095 113c 86E0      		ldi r24,lo8(6)
 4096               	.LVL435:
 4097 113e 00C0      		rjmp .L149
 4098               	.LVL436:
 4099               	.L196:
 703:stk500boot.c  **** 				}
 4100               		.loc 1 703 0
 4101 1140 F12C      		mov r15,__zero_reg__
 4102 1142 E12C      		mov r14,__zero_reg__
 4103               	.LVL437:
 4104               	.L56:
 707:stk500boot.c  **** 				{
 4105               		.loc 1 707 0
 4106 1144 8330      		cpi r24,lo8(3)
 4107 1146 01F4      		brne .+2
 4108 1148 00C0      		rjmp .L140
 4109 114a 00F4      		brsh .L194
 4110 114c 8130      		cpi r24,lo8(1)
 4111 114e 01F4      		brne .+2
 4112 1150 00C0      		rjmp .L142
 4113 1152 00F4      		brsh .+2
 4114 1154 00C0      		rjmp .L149
 4115 1156 00C0      		rjmp .L143
 4116               	.L194:
 4117 1158 8530      		cpi r24,lo8(5)
 4118 115a 01F4      		brne .+2
 4119 115c 00C0      		rjmp .L145
 4120 115e 00F0      		brlo .L206
 4121 1160 8630      		cpi r24,lo8(6)
 4122 1162 01F0      		breq .+2
 4123 1164 00C0      		rjmp .L139
 4124               	.LVL438:
 4125               	.L147:
 771:stk500boot.c  **** 						{
 4126               		.loc 1 771 0
 4127 1166 9B15      		cp r25,r11
 4128 1168 01F4      		brne .+2
 4129 116a 00C0      		rjmp .L208
 4130               	.L206:
 757:stk500boot.c  **** 						}
 4131               		.loc 1 757 0
 4132 116c 80E0      		ldi r24,0
 4133               	.LVL439:
 4134 116e 00C0      		rjmp .L149
 4135               		.cfi_endproc
 4136               	.LFE17:
 4138               		.section	.rodata
 4141               	CSWTCH.59:
 4142 0000 0F        		.byte	15
 4143 0001 02        		.byte	2
 4144 0002 0A        		.byte	10
 4145               	.global	gTextMsg_END
 4146               		.section	.progmem.data,"a",@progbits
 4149               	gTextMsg_END:
 4150 0000 2A00      		.string	"*"
 4151               	.global	gTextMsg_HELP_MSG_Y
 4154               	gTextMsg_HELP_MSG_Y:
 4155 0002 593D 506F 		.string	"Y=Port blink"
 4155      7274 2062 
 4155      6C69 6E6B 
 4155      00
 4156               	.global	gTextMsg_HELP_MSG_V
 4159               	gTextMsg_HELP_MSG_V:
 4160 000f 563D 7368 		.string	"V=show interrupt Vectors"
 4160      6F77 2069 
 4160      6E74 6572 
 4160      7275 7074 
 4160      2056 6563 
 4161               	.global	gTextMsg_HELP_MSG_R
 4164               	gTextMsg_HELP_MSG_R:
 4165 0028 523D 4475 		.string	"R=Dump RAM"
 4165      6D70 2052 
 4165      414D 00
 4166               	.global	gTextMsg_HELP_MSG_Q
 4169               	gTextMsg_HELP_MSG_Q:
 4170 0033 513D 5175 		.string	"Q=Quit"
 4170      6974 00
 4171               	.global	gTextMsg_HELP_MSG_L
 4174               	gTextMsg_HELP_MSG_L:
 4175 003a 4C3D 4C69 		.string	"L=List I/O Ports"
 4175      7374 2049 
 4175      2F4F 2050 
 4175      6F72 7473 
 4175      00
 4176               	.global	gTextMsg_HELP_MSG_H
 4179               	gTextMsg_HELP_MSG_H:
 4180 004b 483D 4865 		.string	"H=Help"
 4180      6C70 00
 4181               	.global	gTextMsg_HELP_MSG_F
 4184               	gTextMsg_HELP_MSG_F:
 4185 0052 463D 4475 		.string	"F=Dump FLASH"
 4185      6D70 2046 
 4185      4C41 5348 
 4185      00
 4186               	.global	gTextMsg_HELP_MSG_E
 4189               	gTextMsg_HELP_MSG_E:
 4190 005f 453D 4475 		.string	"E=Dump EEPROM"
 4190      6D70 2045 
 4190      4550 524F 
 4190      4D00 
 4191               	.global	gTextMsg_HELP_MSG_B
 4194               	gTextMsg_HELP_MSG_B:
 4195 006d 423D 426C 		.string	"B=Blink LED"
 4195      696E 6B20 
 4195      4C45 4400 
 4196               	.global	gTextMsg_HELP_MSG_AT
 4199               	gTextMsg_HELP_MSG_AT:
 4200 0079 403D 4545 		.string	"@=EEPROM test"
 4200      5052 4F4D 
 4200      2074 6573 
 4200      7400 
 4201               	.global	gTextMsg_HELP_MSG_QM
 4204               	gTextMsg_HELP_MSG_QM:
 4205 0087 3F3D 4350 		.string	"?=CPU stats"
 4205      5520 7374 
 4205      6174 7300 
 4206               	.global	gTextMsg_HELP_MSG_0
 4209               	gTextMsg_HELP_MSG_0:
 4210 0093 303D 5A65 		.string	"0=Zero addr"
 4210      726F 2061 
 4210      6464 7200 
 4211               	.global	gTextMsg_PORT
 4214               	gTextMsg_PORT:
 4215 009f 504F 5254 		.string	"PORT"
 4215      00
 4216               	.global	gTextMsg_EEPROMerrorCnt
 4219               	gTextMsg_EEPROMerrorCnt:
 4220 00a4 4545 2065 		.string	"EE err cnt="
 4220      7272 2063 
 4220      6E74 3D00 
 4221               	.global	gTextMsg_ReadingEEprom
 4224               	gTextMsg_ReadingEEprom:
 4225 00b0 5265 6164 		.string	"Reading EE"
 4225      696E 6720 
 4225      4545 00
 4226               	.global	gTextMsg_WriteToEEprom
 4229               	gTextMsg_WriteToEEprom:
 4230 00bb 5772 6974 		.string	"Writting EE"
 4230      7469 6E67 
 4230      2045 4500 
 4231               	.global	gTextMsg_SPACE
 4234               	gTextMsg_SPACE:
 4235 00c7 2000      		.string	" "
 4236               	.global	gTextMsg_MustBeLetter
 4239               	gTextMsg_MustBeLetter:
 4240 00c9 4D75 7374 		.string	"Must be a letter"
 4240      2062 6520 
 4240      6120 6C65 
 4240      7474 6572 
 4240      00
 4241               	.global	gTextMsg_PortNotSupported
 4244               	gTextMsg_PortNotSupported:
 4245 00da 506F 7274 		.string	"Port not supported"
 4245      206E 6F74 
 4245      2073 7570 
 4245      706F 7274 
 4245      6564 00
 4246               	.global	gTextMsg_WHAT_PORT
 4249               	gTextMsg_WHAT_PORT:
 4250 00ed 5768 6174 		.string	"What port:"
 4250      2070 6F72 
 4250      743A 00
 4251               	.global	gTextMsg_jmp
 4254               	gTextMsg_jmp:
 4255 00f8 6A6D 7020 		.string	"jmp "
 4255      00
 4256               	.global	gTextMsg_rjmp
 4259               	gTextMsg_rjmp:
 4260 00fd 726A 6D70 		.string	"rjmp  "
 4260      2020 00
 4261               	.global	gTextMsg_noVector
 4264               	gTextMsg_noVector:
 4265 0104 6E6F 2076 		.string	"no vector"
 4265      6563 746F 
 4265      7200 
 4266               	.global	gTextMsg_VECTOR_HEADER
 4269               	gTextMsg_VECTOR_HEADER:
 4270 010e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 4270      2041 4444 
 4270      5220 2020 
 4270      6F70 2063 
 4270      6F64 6520 
 4271               	.global	gTextMsg_GCC_VERSION_STR
 4274               	gTextMsg_GCC_VERSION_STR:
 4275 0143 372E 332E 		.string	"7.3.0"
 4275      3000 
 4276               	.global	gTextMsg_AVR_LIBC_VER_STR
 4279               	gTextMsg_AVR_LIBC_VER_STR:
 4280 0149 322E 302E 		.string	"2.0.0"
 4280      3000 
 4281               	.global	gTextMsg_GCC_DATE_STR
 4284               	gTextMsg_GCC_DATE_STR:
 4285 014f 4F63 7420 		.string	"Oct 28 2024"
 4285      3238 2032 
 4285      3032 3400 
 4286               	.global	gTextMsg_FUSE_BYTE_LOCK
 4289               	gTextMsg_FUSE_BYTE_LOCK:
 4290 015b 4C6F 636B 		.string	"Lock fuse   = "
 4290      2066 7573 
 4290      6520 2020 
 4290      3D20 00
 4291               	.global	gTextMsg_FUSE_BYTE_EXT
 4294               	gTextMsg_FUSE_BYTE_EXT:
 4295 016a 4578 7420 		.string	"Ext fuse    = "
 4295      6675 7365 
 4295      2020 2020 
 4295      3D20 00
 4296               	.global	gTextMsg_FUSE_BYTE_HIGH
 4299               	gTextMsg_FUSE_BYTE_HIGH:
 4300 0179 4869 6768 		.string	"High fuse   = "
 4300      2066 7573 
 4300      6520 2020 
 4300      3D20 00
 4301               	.global	gTextMsg_FUSE_BYTE_LOW
 4304               	gTextMsg_FUSE_BYTE_LOW:
 4305 0188 4C6F 7720 		.string	"Low fuse    = "
 4305      6675 7365 
 4305      2020 2020 
 4305      3D20 00
 4306               	.global	gTextMsg_CPU_SIGNATURE
 4309               	gTextMsg_CPU_SIGNATURE:
 4310 0197 4350 5520 		.string	"CPU ID      = "
 4310      4944 2020 
 4310      2020 2020 
 4310      3D20 00
 4311               	.global	gTextMsg_GCC_VERSION
 4314               	gTextMsg_GCC_VERSION:
 4315 01a6 4743 4320 		.string	"GCC Version = "
 4315      5665 7273 
 4315      696F 6E20 
 4315      3D20 00
 4316               	.global	gTextMsg_AVR_LIBC
 4319               	gTextMsg_AVR_LIBC:
 4320 01b5 4156 5220 		.string	"AVR LibC Ver= "
 4320      4C69 6243 
 4320      2056 6572 
 4320      3D20 00
 4321               	.global	gTextMsg_AVR_ARCH
 4324               	gTextMsg_AVR_ARCH:
 4325 01c4 5F5F 4156 		.string	"__AVR_ARCH__= "
 4325      525F 4152 
 4325      4348 5F5F 
 4325      3D20 00
 4326               	.global	gTextMsg_CPU_Type
 4329               	gTextMsg_CPU_Type:
 4330 01d3 4350 5520 		.string	"CPU Type    = "
 4330      5479 7065 
 4330      2020 2020 
 4330      3D20 00
 4331               	.global	gTextMsg_COMPILED_ON
 4334               	gTextMsg_COMPILED_ON:
 4335 01e2 436F 6D70 		.string	"Compiled on = "
 4335      696C 6564 
 4335      206F 6E20 
 4335      3D20 00
 4336               	.global	gTextMsg_HUH
 4339               	gTextMsg_HUH:
 4340 01f1 4875 683F 		.string	"Huh?"
 4340      00
 4341               	.global	gTextMsg_Prompt
 4344               	gTextMsg_Prompt:
 4345 01f6 426F 6F74 		.string	"Bootloader>"
 4345      6C6F 6164 
 4345      6572 3E00 
 4346               	.global	gTextMsg_Explorer
 4349               	gTextMsg_Explorer:
 4350 0202 4172 6475 		.string	"Arduino explorer stk500V2 by MLS"
 4350      696E 6F20 
 4350      6578 706C 
 4350      6F72 6572 
 4350      2073 746B 
 4351               	.global	gTextMsg_CPU_Name
 4354               	gTextMsg_CPU_Name:
 4355 0223 4154 6D65 		.string	"ATmega2560"
 4355      6761 3235 
 4355      3630 00
 4356               		.comm	gEepromIndex,4,1
 4357               		.comm	gFlashIndex,4,1
 4358               		.comm	gRamIndex,4,1
 4359               	.global	app_start
 4360               		.section .bss
 4363               	app_start:
 4364 0000 0000      		.zero	2
 4365               		.text
 4366               	.Letext0:
 4367               		.file 3 "/usr/lib/avr/include/stdint.h"
 4368               		.file 4 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 4369               		.file 5 "/usr/lib/avr/include/stdlib.h"
 4370               		.file 6 "/usr/lib/avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
     /tmp/ccVKeXUk.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccVKeXUk.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccVKeXUk.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccVKeXUk.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccVKeXUk.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccVKeXUk.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccVKeXUk.s:12     .text:0000000000000000 sendchar
     /tmp/ccVKeXUk.s:43     .text.unlikely:0000000000000000 recchar
     /tmp/ccVKeXUk.s:67     .init9:0000000000000000 __jumpMain
     /tmp/ccVKeXUk.s:78     *ABS*:00000000000021ff __stack
     /tmp/ccVKeXUk.s:788    .text.startup:0000000000000000 main
     /tmp/ccVKeXUk.s:117    .text:0000000000000018 delay_ms
     /tmp/ccVKeXUk.s:163    .text:0000000000000036 PrintFromPROGMEM
     /tmp/ccVKeXUk.s:226    .text:000000000000005e PrintNewLine
     /tmp/ccVKeXUk.s:247    .text.unlikely:000000000000000e PrintAvailablePort
     /tmp/ccVKeXUk.s:4214   .progmem.data:000000000000009f gTextMsg_PORT
     /tmp/ccVKeXUk.s:285    .text:000000000000006a PrintFromPROGMEMln
     /tmp/ccVKeXUk.s:305    .text:0000000000000072 PrintString
     /tmp/ccVKeXUk.s:348    .text:000000000000008a PrintHexByte
     /tmp/ccVKeXUk.s:408    .text.unlikely:0000000000000028 DumpHex.constprop.0
     /tmp/ccVKeXUk.s:688    .text:00000000000000b8 PrintDecInt
     /tmp/ccVKeXUk.s:4363   .bss:0000000000000000 app_start
     /tmp/ccVKeXUk.s:4189   .progmem.data:000000000000005f gTextMsg_HELP_MSG_E
                            *COM*:0000000000000004 gEepromIndex
     /tmp/ccVKeXUk.s:4174   .progmem.data:000000000000003a gTextMsg_HELP_MSG_L
     /tmp/ccVKeXUk.s:4164   .progmem.data:0000000000000028 gTextMsg_HELP_MSG_R
                            *COM*:0000000000000004 gRamIndex
     /tmp/ccVKeXUk.s:4209   .progmem.data:0000000000000093 gTextMsg_HELP_MSG_0
                            *COM*:0000000000000004 gFlashIndex
     /tmp/ccVKeXUk.s:4204   .progmem.data:0000000000000087 gTextMsg_HELP_MSG_QM
     /tmp/ccVKeXUk.s:4349   .progmem.data:0000000000000202 gTextMsg_Explorer
     /tmp/ccVKeXUk.s:4334   .progmem.data:00000000000001e2 gTextMsg_COMPILED_ON
     /tmp/ccVKeXUk.s:4284   .progmem.data:000000000000014f gTextMsg_GCC_DATE_STR
     /tmp/ccVKeXUk.s:4329   .progmem.data:00000000000001d3 gTextMsg_CPU_Type
     /tmp/ccVKeXUk.s:4354   .progmem.data:0000000000000223 gTextMsg_CPU_Name
     /tmp/ccVKeXUk.s:4324   .progmem.data:00000000000001c4 gTextMsg_AVR_ARCH
     /tmp/ccVKeXUk.s:4314   .progmem.data:00000000000001a6 gTextMsg_GCC_VERSION
     /tmp/ccVKeXUk.s:4274   .progmem.data:0000000000000143 gTextMsg_GCC_VERSION_STR
     /tmp/ccVKeXUk.s:4319   .progmem.data:00000000000001b5 gTextMsg_AVR_LIBC
     /tmp/ccVKeXUk.s:4279   .progmem.data:0000000000000149 gTextMsg_AVR_LIBC_VER_STR
     /tmp/ccVKeXUk.s:4309   .progmem.data:0000000000000197 gTextMsg_CPU_SIGNATURE
     /tmp/ccVKeXUk.s:4304   .progmem.data:0000000000000188 gTextMsg_FUSE_BYTE_LOW
     /tmp/ccVKeXUk.s:4299   .progmem.data:0000000000000179 gTextMsg_FUSE_BYTE_HIGH
     /tmp/ccVKeXUk.s:4294   .progmem.data:000000000000016a gTextMsg_FUSE_BYTE_EXT
     /tmp/ccVKeXUk.s:4289   .progmem.data:000000000000015b gTextMsg_FUSE_BYTE_LOCK
     /tmp/ccVKeXUk.s:4199   .progmem.data:0000000000000079 gTextMsg_HELP_MSG_AT
     /tmp/ccVKeXUk.s:4229   .progmem.data:00000000000000bb gTextMsg_WriteToEEprom
     /tmp/ccVKeXUk.s:4224   .progmem.data:00000000000000b0 gTextMsg_ReadingEEprom
     /tmp/ccVKeXUk.s:4219   .progmem.data:00000000000000a4 gTextMsg_EEPROMerrorCnt
     /tmp/ccVKeXUk.s:4234   .progmem.data:00000000000000c7 gTextMsg_SPACE
     /tmp/ccVKeXUk.s:4194   .progmem.data:000000000000006d gTextMsg_HELP_MSG_B
     /tmp/ccVKeXUk.s:4184   .progmem.data:0000000000000052 gTextMsg_HELP_MSG_F
     /tmp/ccVKeXUk.s:4179   .progmem.data:000000000000004b gTextMsg_HELP_MSG_H
     /tmp/ccVKeXUk.s:4169   .progmem.data:0000000000000033 gTextMsg_HELP_MSG_Q
     /tmp/ccVKeXUk.s:4159   .progmem.data:000000000000000f gTextMsg_HELP_MSG_V
     /tmp/ccVKeXUk.s:4154   .progmem.data:0000000000000002 gTextMsg_HELP_MSG_Y
     /tmp/ccVKeXUk.s:4269   .progmem.data:000000000000010e gTextMsg_VECTOR_HEADER
     /tmp/ccVKeXUk.s:4264   .progmem.data:0000000000000104 gTextMsg_noVector
     /tmp/ccVKeXUk.s:4259   .progmem.data:00000000000000fd gTextMsg_rjmp
     /tmp/ccVKeXUk.s:4254   .progmem.data:00000000000000f8 gTextMsg_jmp
     /tmp/ccVKeXUk.s:4249   .progmem.data:00000000000000ed gTextMsg_WHAT_PORT
     /tmp/ccVKeXUk.s:4244   .progmem.data:00000000000000da gTextMsg_PortNotSupported
     /tmp/ccVKeXUk.s:4239   .progmem.data:00000000000000c9 gTextMsg_MustBeLetter
     /tmp/ccVKeXUk.s:4344   .progmem.data:00000000000001f6 gTextMsg_Prompt
     /tmp/ccVKeXUk.s:4339   .progmem.data:00000000000001f1 gTextMsg_HUH
     /tmp/ccVKeXUk.s:4141   .rodata:0000000000000000 CSWTCH.59
     /tmp/ccVKeXUk.s:4149   .progmem.data:0000000000000000 gTextMsg_END

UNDEFINED SYMBOLS
eeprom_read_byte
__divmodhi4
__udivmodsi4
eeprom_write_byte
__bswapsi2
__do_copy_data
__do_clear_bss
